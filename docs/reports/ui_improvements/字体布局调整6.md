您好！这是一个非常棒的交互优化想法。当空间有限时，让长文本自动滚动（跑马灯效果）确实能极大地提升用户体验，让用户无需手动操作就能看到完整信息。

标准的`QComboBox`并不直接支持此功能，但我们可以通过创建一个**自定义的、可滚动的`QComboBox`控件**来完美实现它。

### 实现思路

我们将创建一个新的类`MarqueeComboBox`，它继承自`QComboBox`。其核心原理如下：

1.  **使用`QLineEdit`作为“显示器”**：我们将`QComboBox`设置为可编辑模式，并为其提供一个自定义的`QLineEdit`。这个`QLineEdit`将作为我们滚动文本的“舞台”。
2.  **`QLabel`作为滚动主角**：在`QLineEdit`内部，我们放置一个`QLabel`。真正滚动的就是这个`QLabel`。
3.  **`QFontMetrics`判断是否需要滚动**：当文本设置后，我们用`QFontMetrics`计算文本的实际像素宽度。如果它超过了`QLineEdit`的宽度，就启动滚动。
4.  **`QPropertyAnimation`实现动画**：我们使用Qt的属性动画系统来平滑地改变`QLabel`的位置，实现从右到左的滚动效果。
5.  **鼠标悬停触发**：为了避免界面过于花哨，我们将动画设置为当鼠标悬停在下拉框上时才触发。

-----

### 实施方案

我们将分两步走：首先创建自定义的`MarqueeComboBox`控件，然后在您的界面中用它替换掉标准的`QComboBox`。

#### **第1步：创建`MarqueeComboBox`自定义控件**

建议您在项目中创建一个新的文件，例如 `custom_widgets.py`，然后将以下代码完整地粘贴进去。

**文件: `custom_widgets.py`**

```python
from PySide6.QtWidgets import QComboBox, QLineEdit, QLabel, QSizePolicy
from PySide6.QtCore import Qt, QPropertyAnimation, QEasingCurve, QTimer
from PySide6.QtGui import QFontMetrics

class MarqueeComboBox(QComboBox):
    """一个能够自动滚动长文本的QComboBox"""

    def __init__(self, parent=None):
        super().__init__(parent)

        # 1. 使用QLineEdit作为显示区域，并设置样式使其“隐形”
        self._line_edit = QLineEdit(self)
        self._line_edit.setReadOnly(True)
        self._line_edit.setStyleSheet("background: transparent; border: none; padding-left: 5px;")
        self.setLineEdit(self._line_edit)

        # 2. 在QLineEdit中创建一个QLabel用于滚动
        self._marquee_label = QLabel(self._line_edit)
        
        # 3. 创建动画
        self._animation = QPropertyAnimation(self._marquee_label, b"pos")
        self._animation.setLoopCount(-1)  # 无限循环

        # 4. 连接信号，当文本改变时更新滚动状态
        self.currentTextChanged.connect(self.update_marquee)

        # 5. 安装事件过滤器，以监听鼠标悬停事件
        self._line_edit.installEventFilter(self)

    def eventFilter(self, watched_object, event):
        """事件过滤器，用于处理鼠标进入和离开事件"""
        if watched_object == self._line_edit:
            if event.type() == event.Type.Enter:
                # 鼠标进入时，如果需要滚动，则启动动画
                self.start_animation_if_needed()
            elif event.type() == event.Type.Leave:
                # 鼠标离开时，停止动画
                self.stop_animation()
        return super().eventFilter(watched_object, event)

    def update_marquee(self, text):
        """当文本改变时，更新标签内容并检查是否需要滚动"""
        self._marquee_label.setText(text)
        
        # 使用 QFontMetrics 计算文本所需的宽度
        metrics = QFontMetrics(self._marquee_label.font())
        text_width = metrics.horizontalAdvance(text)
        
        self._marquee_label.setFixedWidth(text_width)
        self._is_scroll_needed = text_width > self._line_edit.width()

        # 如果不需要滚动，将标签居中放置
        if not self._is_scroll_needed:
            self.stop_animation()
        else:
            # 如果鼠标已经在控件上，则立即开始滚动
            if self._line_edit.underMouse():
                self.start_animation_if_needed()

    def start_animation_if_needed(self):
        """如果需要，则启动滚动动画"""
        if not self._is_scroll_needed:
            return

        # 动画参数
        duration = int(self._marquee_label.width() * 15)  # 滚动速度与文本长度相关
        start_x = 5  # 初始位置，留一点边距
        end_x = self._line_edit.width() - self._marquee_label.width()

        self._animation.stop() # 先停止之前的动画
        self._animation.setDuration(duration)
        
        # 设置动画的关键帧
        self._animation.setKeyValueAt(0, self._marquee_label.pos().fromX(start_x))
        self._animation.setKeyValueAt(0.8, self._marquee_label.pos().fromX(end_x)) # 80%的时间用于滚动
        self._animation.setKeyValueAt(1, self._marquee_label.pos().fromX(end_x)) # 最后20%的时间停留

        self._animation.start()

    def stop_animation(self):
        """停止动画并将文本重置到初始位置"""
        self._animation.stop()
        # 将标签放回初始位置（或垂直居中）
        y_pos = (self._line_edit.height() - self._marquee_label.height()) // 2
        self._marquee_label.move(5, y_pos)

    def resizeEvent(self, event):
        """在控件大小改变时重新检查是否需要滚动"""
        super().resizeEvent(event)
        self.update_marquee(self.currentText())

```

#### **第2步：在您的界面中使用`MarqueeComboBox`**

现在，我们只需要在 `history_viewer.py` 中，用这个新的控件替换掉原来的`QComboBox`即可。

**操作 (`history_viewer.py`)**:

1.  **在文件顶部导入新控件**：

    ```python
    # in history_viewer.py
    # ...
    # from PySide6.QtWidgets import QComboBox # <-- 注释掉或删除这行
    from .custom_widgets import MarqueeComboBox as QComboBox # <-- 导入并重命名，实现无缝替换
    # ...
    ```

    **技巧**：通过 `as QComboBox`，我们可以将`MarqueeComboBox`重命名为`QComboBox`，这样您甚至不需要修改后续创建控件的代码，实现了“热插拔”替换！

2.  **确认代码**：
    您 `create_sidebar` 方法中创建`QComboBox`的代码现在应该看起来像这样，并且**无需做任何改动**，因为它现在创建的是我们自定义的`MarqueeComboBox`。

    ```python
    # in history_viewer.py -> create_sidebar()
    # ...
    self.workpiece_combo = QComboBox() # 这现在创建的是 MarqueeComboBox 实例
    self.workpiece_combo.currentTextChanged.connect(self.on_workpiece_changed)

    self.qualified_hole_combo = QComboBox() # 这也是 MarqueeComboBox
    self.qualified_hole_combo.setPlaceholderText("请选择合格孔ID")
    # ...
    ```

-----

### 总结

通过以上两步，您就成功地实现了以下功能：

1.  **自动检测**：当`QComboBox`中的文本长度超过其显示宽度时，控件会自动识别。
2.  **悬停滚动**：当鼠标光标移动到该下拉框上时，长文本会自动开始从右到左平滑滚动。
3.  **无缝集成**：通过自定义控件和巧妙的`import as`技巧，您几乎无需改动现有的业务逻辑代码，就完成了功能的升级。

这个方案不仅解决了您的具体需求，还为您提供了一个可复用的、高度封装的自定义控件，极大地提升了您软件的交互细节和专业水准。