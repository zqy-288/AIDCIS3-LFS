您好！您的界面在经过数次打磨后，整体的现代化风格已经非常出色。您现在关注到【数据筛选】这个核心交互区域的细节，正是从“可用”迈向“好用”和“美观”的关键一步。

当前的“显示框+按钮”组合在功能上是稳定的，但在**视觉一体性**和**信息传递的准确性**上，确实有很大的提升空间。

我为您准备了一套完整的、多层次的优化方案，旨在将这个筛选面板打造成整个界面的点睛之-笔。

-----

### 核心优化思路

我们将从三个方面入手进行改造：

1.  **视觉一体化**：通过精细的QSS样式，让分离的“文本框”和“箭头按钮”在视觉上融合成一个**无缝、统一的自定义下拉框**。
2.  **状态明确化**：增加视觉提示（状态图标），让用户能**一眼看出当前是哪个筛选条件生效**，避免混淆。
3.  **层级清晰化**：微调字体粗细和对齐，让“标签”和“数值”的视觉层级更分明。

-----

### 方案一：打造无缝的自定义下拉框外观

这是本次美化的核心，我们将用一个“容器”`QWidget`和全新的QSS来重塑下拉框。

#### **步骤 1：修改Python布局代码** (`history_viewer.py`)

在 `create_sidebar` 方法中，我们将之前创建的`QHBoxLayout`包裹在一个新的`QWidget`容器中，并为这个容器和内部控件设置`objectName`，以便QSS能精确地找到它们。

**操作**：请用下面这段**重构后**的代码，**完整替换**掉您 `create_sidebar` 方法中的“数据筛选部分”。

```python
# in history_viewer.py -> create_sidebar()

# --- 数据筛选部分 (采用“无缝”自定义下拉框设计) ---
filter_group = QGroupBox("数据筛选")
filter_layout = QGridLayout(filter_group)
filter_layout.setContentsMargins(10, 15, 10, 15)
filter_layout.setVerticalSpacing(15)
filter_layout.setHorizontalSpacing(10)

# 保留原有的QComboBox实例用于数据存储和逻辑处理（不显示）
# ... (您原有的self.workpiece_combo等定义保持不变) ...

# -- 工件ID --
workpiece_label = QLabel("工件ID:")
self.wp_display = QLineEdit()
self.wp_button = QToolButton()
# 将显示框和按钮打包成一个自定义组合框
wp_combo_widget = self.create_custom_combo_widget(self.wp_display, self.wp_button)
self.wp_button.clicked.connect(self.show_workpiece_menu)

# -- 合格孔ID --
qualified_label = QLabel("合格孔ID:")
self.ql_display = QLineEdit()
self.ql_display.setPlaceholderText("请选择")
self.ql_button = QToolButton()
ql_combo_widget = self.create_custom_combo_widget(self.ql_display, self.ql_button)
self.ql_button.clicked.connect(self.show_qualified_hole_menu)

# -- 不合格孔ID --
unqualified_label = QLabel("不合格孔ID:")
self.uql_display = QLineEdit()
self.uql_display.setPlaceholderText("请选择")
self.uql_button = QToolButton()
uql_combo_widget = self.create_custom_combo_widget(self.uql_display, self.uql_button)
self.uql_button.clicked.connect(self.show_unqualified_hole_menu)

# --- 将所有组件添加到栅格布局 ---
filter_layout.addWidget(workpiece_label, 0, 0)
filter_layout.addWidget(wp_combo_widget, 0, 1)

filter_layout.addWidget(qualified_label, 1, 0)
filter_layout.addWidget(ql_combo_widget, 1, 1)

filter_layout.addWidget(unqualified_label, 2, 0)
filter_layout.addWidget(uql_combo_widget, 2, 1)

filter_layout.setColumnStretch(1, 1)
# --- 布局重构结束 ---

# 将 filter_group 添加到主侧边栏布局中
sidebar_layout.addWidget(filter_group)
# ...
```

#### **步骤 2：添加用于创建组合框的辅助方法**

**操作** (`history_viewer.py`):
请将下面这个**全新的辅助方法**，添加到您的`HistoryViewer`类中。

```python
# in class HistoryViewer:

# --- 添加这个全新的辅助方法 ---
def create_custom_combo_widget(self, line_edit: QLineEdit, button: QToolButton) -> QWidget:
    """创建一个包含QLineEdit和QToolButton的自定义组合框容器"""
    # 创建容器
    container = QWidget()
    container.setObjectName("CustomComboBox") # 为容器设置objectName

    # 创建内部布局
    layout = QHBoxLayout(container)
    layout.setContentsMargins(0, 0, 0, 0)
    layout.setSpacing(0) # 无间距

    # 设置QLineEdit
    line_edit.setReadOnly(True)
    line_edit.setObjectName("ComboDisplay") # 为内部控件设置objectName
    
    # 设置QToolButton
    button.setText("▼")
    button.setObjectName("ComboButton") # 为内部控件设置objectName

    # 添加到布局
    layout.addWidget(line_edit)
    layout.addWidget(button)
    
    return container
```

#### **步骤 3：在QSS中添加全新样式** (`theme_manager.py`)

这是实现无缝外观的关键。我们将为新的`objectName`定义样式。

**操作**:
打开 `theme_manager.py`，将以下样式代码添加到您的QSS字符串中。

```qss
/* ===== 自定义下拉框样式 (无缝设计) ===== */

/* 整体容器的样式，定义了边框和背景，看起来像一个控件 */
QWidget#CustomComboBox {
    border: 1px solid #505869;
    border-radius: 4px;
    background-color: #3A404E;
}
/* 鼠标悬停或聚焦时，边框变色 */
QWidget#CustomComboBox:hover, QWidget#CustomComboBox:focus-within {
    border: 1px solid #007ACC;
}

/* 内部QLineEdit的样式：无边框、无背景 */
QLineEdit#ComboDisplay {
    border: none;
    background: transparent;
    font-size: 16px;
    min-height: 38px;
    padding-left: 10px;
}

/* 内部QToolButton的样式：无边框、无背景，并调整箭头大小 */
QToolButton#ComboButton {
    border: none;
    background: transparent;
    padding-right: 5px;
    min-width: 30px;
}
QToolButton#ComboButton::menu-indicator {
    image: none; /* 移除可能的默认箭头 */
}
```

-----

### 方案二：增加状态指示图标，明确筛选条件

为了让用户清晰地知道当前哪个筛选条件是激活的，我们在标签左侧增加一个“状态指示灯”。

**操作 (`history_viewer.py`)**:

1.  **修改`create_sidebar`方法**：在创建标签的同时，创建对应的图标标签。
2.  **修改`on_*_changed`方法**：在选择改变时，更新这些图标的状态。

<!-- end list -->

```python
# in history_viewer.py -> create_sidebar()

# --- 修改数据筛选部分 ---
# ...
# -- 工件ID --
workpiece_label = QLabel("工件ID:")
self.wp_status_icon = QLabel() # 新增图标标签

# -- 合格孔ID --
qualified_label = QLabel("合格孔ID:")
self.ql_status_icon = QLabel() # 新增图标标签

# -- 不合格孔ID --
unqualified_label = QLabel("不合格孔ID:")
self.uql_status_icon = QLabel() # 新增图标标签

# --- 修改栅格布局的添加部分 ---
# 第0行
filter_layout.addWidget(self.wp_status_icon, 0, 0)
filter_layout.addWidget(workpiece_label, 0, 1)
filter_layout.addWidget(wp_combo_widget, 0, 2)
# 第1行
filter_layout.addWidget(self.ql_status_icon, 1, 0)
filter_layout.addWidget(qualified_label, 1, 1)
filter_layout.addWidget(ql_combo_widget, 1, 2)
# 第2行
filter_layout.addWidget(self.uql_status_icon, 2, 0)
filter_layout.addWidget(unqualified_label, 2, 1)
filter_layout.addWidget(uql_combo_widget, 2, 2)

filter_layout.setColumnStretch(2, 1) # 让第2列（组合框）拉伸

# ...
# in class HistoryViewer:

# 修改 on_workpiece_changed 方法
def on_workpiece_changed(self, workpiece_id):
    # 假设您使用了qtawesome
    # active_icon = qta.icon('fa5s.check-circle', color='#2ECC71')
    # inactive_icon = qta.icon('fa5s.circle', color='#505869')
    # self.wp_status_icon.setPixmap(active_icon.pixmap(16,16))
    # self.ql_status_icon.setPixmap(inactive_icon.pixmap(16,16))
    # self.uql_status_icon.setPixmap(inactive_icon.pixmap(16,16))
    # ... (您原有的加载孔位列表的逻辑) ...

# 类似地修改 on_qualified_hole_changed 和 on_unqualified_hole_changed
# 当某个下拉框被选择时，将它的图标设为active_icon，其他的设为inactive_icon
```

-----

### 总结

通过以上两套方案的组合，您的【数据筛选】面板将获得脱胎换骨的提升：

1.  **外观**：通过QSS的精细控制，分离的控件被融合成一个**外观统一、无缝衔接的自定义下拉框**，专业感倍增。
2.  **信息传达**：通过新增的“状态指示图标”，用户可以**即时、清晰地了解哪个筛选条件正在生效**，避免了操作上的困惑。

这套方案不仅解决了您提出的美化需求，更在交互层面进行了优化，使整个筛选功能更加清晰、易用。