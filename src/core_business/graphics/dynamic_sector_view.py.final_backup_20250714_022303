"""
åŠ¨æ€æ‰‡å½¢åŒºåŸŸå›¾å½¢ç®¡ç†å™¨
æ ¹æ®æ£€æµ‹è¿›åº¦åŠ¨æ€æ˜¾ç¤ºå¯¹åº”æ‰‡å½¢åŒºåŸŸçš„DXFå›¾å½¢éƒ¨åˆ†
"""

import math
from typing import Dict, List, Optional, Tuple
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, QGraphicsItem, QGraphicsPathItem
from PySide6.QtCore import Qt, QPointF, QRectF, Signal, QTimer, QEvent
from PySide6.QtGui import QColor, QFont, QPainter, QPen, QBrush, QPainterPath, QTransform

from aidcis2.graphics.graphics_view import OptimizedGraphicsView
from aidcis2.graphics.sector_manager import SectorManager, SectorQuadrant, SectorProgress
from aidcis2.models.hole_data import HoleData, HoleCollection


class SectorHighlightItem(QGraphicsPathItem):
    """æ‰‡å½¢åŒºåŸŸé«˜äº®æ˜¾ç¤ºå›¾å½¢é¡¹"""
    
    def __init__(self, sector: SectorQuadrant, center: QPointF, radius: float, sector_bounds: Optional[Tuple[float, float, float, float]] = None, parent=None):
        super().__init__(parent)
        self.sector = sector
        self.center = center
        self.radius = radius
        self.sector_bounds = sector_bounds  # (min_x, min_y, max_x, max_y)
        self.highlight_mode = "sector"  # "sector" æˆ– "bounds"
        self.setup_highlight()
    
    def setup_highlight(self):
        """è®¾ç½®é«˜äº®æ˜¾ç¤ºæ ·å¼"""
        path = QPainterPath()
        
        if self.highlight_mode == "bounds" and self.sector_bounds:
            # è¾¹ç•Œæ¡†æ¨¡å¼ï¼šç»˜åˆ¶çŸ©å½¢è¾¹ç•Œ
            min_x, min_y, max_x, max_y = self.sector_bounds
            rect = QRectF(min_x, min_y, max_x - min_x, max_y - min_y)
            path.addRect(rect)
            
            # è¾¹ç•Œæ¡†æ ·å¼ï¼šæ›´æ·¡çš„é¢œè‰²ï¼Œè™šçº¿è¾¹æ¡†
            highlight_color = QColor(76, 175, 80, 60)  # æ·¡ç»¿è‰²ï¼Œæ›´é€æ˜
            border_color = QColor(76, 175, 80, 120)    # ç»¿è‰²è¾¹æ¡†
            pen = QPen(border_color, 2, Qt.DashLine)
            
        else:
            # æ‰‡å½¢æ¨¡å¼ï¼šç»˜åˆ¶æ‰‡å½¢åŒºåŸŸ
            start_angle, span_angle = self._get_sector_angles()
            
            # ç§»åŠ¨åˆ°ä¸­å¿ƒç‚¹
            path.moveTo(self.center)
            
            # ç»˜åˆ¶æ‰‡å½¢
            rect = QRectF(
                self.center.x() - self.radius, 
                self.center.y() - self.radius,
                self.radius * 2, 
                self.radius * 2
            )
            path.arcTo(rect, start_angle, span_angle)
            path.closeSubpath()
            
            # æ‰‡å½¢æ ·å¼ï¼šé»„è‰²åŠé€æ˜
            highlight_color = QColor(255, 193, 7, 80)  # æ·¡é»„è‰²ï¼ŒåŠé€æ˜
            border_color = QColor(255, 193, 7, 150)   # è¾¹æ¡†ç¨æ·±
            pen = QPen(border_color, 2, Qt.SolidLine)
        
        self.setPath(path)
        self.setBrush(QBrush(highlight_color))
        self.setPen(pen)
        
        # è®¾ç½®å›¾å±‚çº§åˆ«ï¼ˆåœ¨å­”ä½ä¸Šæ–¹ä½†ä¸é®æŒ¡ï¼‰
        self.setZValue(10)  # é«˜äºå­”ä½å›¾å½¢é¡¹
        
        # ç¡®ä¿é«˜äº®é¡¹ä¸ä¼šé˜»æŒ¡é¼ æ ‡äº‹ä»¶
        self.setAcceptedMouseButtons(Qt.NoButton)
        self.setAcceptHoverEvents(False)
        
        # é»˜è®¤éšè—
        self.setVisible(False)
    
    def _get_sector_angles(self) -> Tuple[float, float]:
        """è·å–æ‰‡å½¢çš„èµ·å§‹è§’åº¦å’Œè·¨åº¦è§’åº¦"""
        # Qtçš„è§’åº¦ç³»ç»Ÿï¼š0åº¦åœ¨3ç‚¹é’Ÿæ–¹å‘ï¼Œé¡ºæ—¶é’ˆä¸ºæ­£
        # ä½†æ˜¯æ•°æ®ä½¿ç”¨æ•°å­¦åæ ‡ç³»ï¼š0åº¦åœ¨å³è¾¹ï¼Œé€†æ—¶é’ˆä¸ºæ­£
        # éœ€è¦è½¬æ¢ï¼šQtè§’åº¦ = -æ•°å­¦è§’åº¦
        # æ•°å­¦åæ ‡ç³»ï¼š
        #   æ‰‡å½¢1: 0Â°-90Â° (å³ä¸Š)
        #   æ‰‡å½¢2: 90Â°-180Â° (å·¦ä¸Š)
        #   æ‰‡å½¢3: 180Â°-270Â° (å·¦ä¸‹)
        #   æ‰‡å½¢4: 270Â°-360Â° (å³ä¸‹)
        # Qtåæ ‡ç³»ï¼ˆé¡ºæ—¶é’ˆï¼‰ï¼š
        #   æ‰‡å½¢1: 0Â°åˆ°-90Â° => 270Â°åˆ°360Â°
        #   æ‰‡å½¢2: -90Â°åˆ°-180Â° => 180Â°åˆ°270Â°
        #   æ‰‡å½¢3: -180Â°åˆ°-270Â° => 90Â°åˆ°180Â°
        #   æ‰‡å½¢4: -270Â°åˆ°-360Â° => 0Â°åˆ°90Â°
        angle_map = {
            SectorQuadrant.SECTOR_1: (270, 90),    # å³ä¸Šï¼š270Â°-360Â°
            SectorQuadrant.SECTOR_2: (180, 90),    # å·¦ä¸Šï¼š180Â°-270Â°
            SectorQuadrant.SECTOR_3: (90, 90),     # å·¦ä¸‹ï¼š90Â°-180Â°
            SectorQuadrant.SECTOR_4: (0, 90),      # å³ä¸‹ï¼š0Â°-90Â°
        }
        return angle_map.get(self.sector, (0, 90))
    
    def show_highlight(self):
        """æ˜¾ç¤ºé«˜äº®"""
        self.setVisible(True)
        self.update()
    
    def hide_highlight(self):
        """éšè—é«˜äº®"""
        self.setVisible(False)
        self.update()
    
    def set_highlight_mode(self, mode: str):
        """è®¾ç½®é«˜äº®æ¨¡å¼
        
        Args:
            mode: "sector" ç”¨äºæ‰‡å½¢é«˜äº®ï¼Œ"bounds" ç”¨äºè¾¹ç•Œæ¡†é«˜äº®
        """
        if mode in ["sector", "bounds"]:
            self.highlight_mode = mode
            self.setup_highlight()
            print(f"ğŸ¨ [é«˜äº®] æ‰‡å½¢ {self.sector.value} åˆ‡æ¢åˆ° {mode} æ¨¡å¼")


class SectorGraphicsManager:
    """æ‰‡å½¢å›¾å½¢ç®¡ç†å™¨ - è´Ÿè´£å°†DXFå›¾å½¢åˆ’åˆ†ä¸º4ä¸ªæ‰‡å½¢åŒºåŸŸ"""
    
    def __init__(self, hole_collection: HoleCollection, center_point: Optional[QPointF] = None):
        self.hole_collection = hole_collection
        self.center_point = center_point if center_point else self._calculate_center()
        self.sector_collections = self._create_sector_collections()
    
    def _calculate_center(self) -> QPointF:
        """è®¡ç®—DXFå›¾å½¢çš„ä¸­å¿ƒç‚¹"""
        if not self.hole_collection:
            return QPointF(0, 0)
        
        bounds = self.hole_collection.get_bounds()
        center_x = (bounds[0] + bounds[2]) / 2
        center_y = (bounds[1] + bounds[3]) / 2
        return QPointF(center_x, center_y)
    
    def _create_sector_collections(self) -> Dict[SectorQuadrant, HoleCollection]:
        """ä¸ºæ¯ä¸ªæ‰‡å½¢åŒºåŸŸåˆ›å»ºç‹¬ç«‹çš„å­”ä½é›†åˆ"""
        sector_collections = {}
        
        for sector in SectorQuadrant:
            sector_holes = {}
            
            for hole_id, hole in self.hole_collection.holes.items():
                if self._is_hole_in_sector(hole, sector):
                    sector_holes[hole_id] = hole
            
            # åˆ›å»ºæ‰‡å½¢ä¸“ç”¨çš„å­”ä½é›†åˆ
            sector_collection = HoleCollection(
                holes=sector_holes,
                metadata={
                    'sector': sector,
                    'source_file': self.hole_collection.metadata.get('source_file', ''),
                    'total_holes': len(sector_holes),
                    'sector_bounds': None  # å…ˆè®¾ç½®ä¸ºNoneï¼Œåç»­è®¡ç®—
                }
            )
            
            sector_collections[sector] = sector_collection
        
        # ç°åœ¨è®¡ç®—æ¯ä¸ªæ‰‡å½¢çš„è¾¹ç•Œå¹¶æ›´æ–°metadata
        for sector, collection in sector_collections.items():
            if collection and len(collection) > 0:
                bounds = collection.get_bounds()
                collection.metadata['sector_bounds'] = bounds
        
        return sector_collections
    
    def _is_hole_in_sector(self, hole: HoleData, sector: SectorQuadrant) -> bool:
        """åˆ¤æ–­å­”ä½æ˜¯å¦å±äºæŒ‡å®šæ‰‡å½¢åŒºåŸŸ"""
        dx = hole.center_x - self.center_point.x()
        dy = hole.center_y - self.center_point.y()
        
        # è®¡ç®—è§’åº¦
        angle_rad = math.atan2(dy, dx)
        angle_deg = math.degrees(angle_rad)
        
        # è½¬æ¢ä¸º0-360åº¦èŒƒå›´
        if angle_deg < 0:
            angle_deg += 360
        
        # åˆ¤æ–­å±äºå“ªä¸ªæ‰‡å½¢
        # å°†æ•°å­¦åæ ‡ç³»è§’åº¦è½¬æ¢ä¸ºQtåæ ‡ç³»è§’åº¦ï¼ˆé¡ºæ—¶é’ˆï¼‰
        # ä½¿ç”¨ä¸ä¸»è§†å›¾SectorManagerç›¸åŒçš„æ•°å­¦åæ ‡ç³»ï¼ˆä¸è½¬æ¢ï¼‰
        # ç›´æ¥ä½¿ç”¨æ•°å­¦è§’åº¦ç³»ç»Ÿï¼Œä¸ä¸»è§†å›¾ä¿æŒä¸€è‡´
        
        # æ•°å­¦åæ ‡ç³»ä¸­çš„æ‰‡å½¢å®šä¹‰ï¼ˆä¸SectorManagerä¿æŒä¸€è‡´ï¼‰ï¼š
        # åŒºåŸŸ1ï¼š0Â°-90Â°ï¼ˆå³ä¸Šï¼‰
        # åŒºåŸŸ2ï¼š90Â°-180Â°ï¼ˆå·¦ä¸Šï¼‰
        # åŒºåŸŸ3ï¼š180Â°-270Â°ï¼ˆå·¦ä¸‹ï¼‰
        # åŒºåŸŸ4ï¼š270Â°-360Â°ï¼ˆå³ä¸‹ï¼‰
        if sector == SectorQuadrant.SECTOR_1:
            return 0 <= angle_deg < 90      # å³ä¸Š
        elif sector == SectorQuadrant.SECTOR_2:
            return 90 <= angle_deg < 180    # å·¦ä¸Š
        elif sector == SectorQuadrant.SECTOR_3:
            return 180 <= angle_deg < 270   # å·¦ä¸‹
        elif sector == SectorQuadrant.SECTOR_4:
            return 270 <= angle_deg < 360   # å³ä¸‹
        
        return False
    
    def _get_sector_bounds(self, sector: SectorQuadrant) -> Tuple[float, float, float, float]:
        """è·å–æ‰‡å½¢åŒºåŸŸçš„è¾¹ç•ŒèŒƒå›´"""
        # ä»å·²åˆ›å»ºçš„æ‰‡å½¢é›†åˆä¸­è·å–è¾¹ç•Œï¼Œé¿å…é€’å½’è°ƒç”¨
        if sector in self.sector_collections:
            sector_collection = self.sector_collections[sector]
            if sector_collection and len(sector_collection) > 0:
                return sector_collection.get_bounds()
        
        # å¦‚æœæ‰‡å½¢é›†åˆè¿˜æœªåˆ›å»ºï¼Œç›´æ¥è®¡ç®—è¯¥æ‰‡å½¢çš„å­”ä½è¾¹ç•Œ
        sector_holes = []
        for hole_id, hole in self.hole_collection.holes.items():
            if self._is_hole_in_sector(hole, sector):
                sector_holes.append(hole)
        
        if not sector_holes:
            return (0, 0, 0, 0)
        
        min_x = min(hole.center_x for hole in sector_holes)
        max_x = max(hole.center_x for hole in sector_holes)
        min_y = min(hole.center_y for hole in sector_holes)
        max_y = max(hole.center_y for hole in sector_holes)
        
        return (min_x, min_y, max_x, max_y)
    
    def get_sector_collection(self, sector: SectorQuadrant) -> Optional[HoleCollection]:
        """è·å–æŒ‡å®šæ‰‡å½¢åŒºåŸŸçš„å­”ä½é›†åˆ"""
        return self.sector_collections.get(sector)
    
    def get_all_sector_collections(self) -> Dict[SectorQuadrant, HoleCollection]:
        """è·å–æ‰€æœ‰æ‰‡å½¢åŒºåŸŸçš„å­”ä½é›†åˆ"""
        return self.sector_collections.copy()


class DynamicSectorDisplayWidget(QWidget):
    """åŠ¨æ€æ‰‡å½¢åŒºåŸŸæ˜¾ç¤ºç»„ä»¶"""
    
    sector_changed = Signal(SectorQuadrant)  # æ‰‡å½¢åˆ‡æ¢ä¿¡å·
    
    # é»˜è®¤é…ç½®å¸¸é‡
    DEFAULT_SECTOR_OFFSET_RATIO = 0.10  # é»˜è®¤10%å‘å³åç§»
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.sector_graphics_manager: Optional[SectorGraphicsManager] = None
        self.complete_hole_collection: Optional[HoleCollection] = None  # ä¿å­˜å®Œæ•´å­”ä½é›†åˆ
        self.current_sector = SectorQuadrant.SECTOR_1
        self.sector_views = {}  # ç¼“å­˜å„æ‰‡å½¢çš„å›¾å½¢è§†å›¾
        
        # å¯é…ç½®çš„æ‰‡å½¢æ˜¾ç¤ºåç§»è®¾ç½®
        self.sector_offset_ratio = self.DEFAULT_SECTOR_OFFSET_RATIO
        self.sector_offset_enabled = True
        
        self.setup_ui()
    
    def set_sector_offset_config(self, ratio: float = None, enabled: bool = None):
        """é…ç½®æ‰‡å½¢æ˜¾ç¤ºåç§»
        
        Args:
            ratio: åç§»æ¯”ä¾‹ï¼Œé™åˆ¶åœ¨0-0.5ä¹‹é—´
            enabled: æ˜¯å¦å¯ç”¨åç§»
        """
        # æ£€æŸ¥æ˜¯å¦çœŸçš„æœ‰å˜åŒ–ï¼Œé¿å…æ— æ•ˆåˆ·æ–°
        config_changed = False
        
        if ratio is not None:
            new_ratio = max(0.0, min(0.5, ratio))  # é™åˆ¶åœ¨0-50%
            if abs(new_ratio - self.sector_offset_ratio) > 0.001:  # åªæœ‰æ˜¾è‘—å˜åŒ–æ‰æ›´æ–°
                self.sector_offset_ratio = new_ratio
                config_changed = True
                print(f"ğŸ”§ [é…ç½®] æ‰‡å½¢åç§»æ¯”ä¾‹å·²è®¾ç½®ä¸º: {self.sector_offset_ratio:.1%}")
        
        if enabled is not None:
            if self.sector_offset_enabled != enabled:
                self.sector_offset_enabled = enabled
                config_changed = True
                print(f"ğŸ”§ [é…ç½®] æ‰‡å½¢åç§»å·²{'å¯ç”¨' if enabled else 'ç¦ç”¨'}")
        
        # åªæœ‰åœ¨é…ç½®çœŸæ­£æ”¹å˜æ—¶æ‰åˆ·æ–°ï¼Œé¿å…æ— é™å¾ªç¯
        if config_changed and hasattr(self, 'current_sector') and hasattr(self, 'sector_graphics_manager') and self.sector_graphics_manager:
            print(f"ğŸ”„ [é…ç½®] é…ç½®å·²å˜åŒ–ï¼Œåˆ·æ–°å½“å‰æ‰‡å½¢: {self.current_sector.value}")
            self.switch_to_sector(self.current_sector)
    
    def setup_ui(self):
        """è®¾ç½®ç”¨æˆ·ç•Œé¢"""
        # ä½¿ç”¨æ— è¾¹è·çš„ä¸»å¸ƒå±€
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # ä¸»å›¾å½¢æ˜¾ç¤ºåŒºåŸŸï¼ˆå æ®å…¨éƒ¨ç©ºé—´ï¼‰
        self.graphics_view = OptimizedGraphicsView()
        self.graphics_view.setFrameStyle(QFrame.StyledPanel)
        # è®¾ç½®æœ€å°å°ºå¯¸ç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´
        self.graphics_view.setMinimumSize(500, 400)
        
        main_layout.addWidget(self.graphics_view)
        
        # æ·»åŠ çŠ¶æ€æ ‡ç­¾ç”¨äºæ˜¾ç¤ºæç¤ºä¿¡æ¯ï¼ˆæ‰©å±•é«˜åº¦ï¼‰
        self.status_label = QLabel("è¯·é€‰æ‹©äº§å“å‹å·æˆ–åŠ è½½DXFæ–‡ä»¶")
        self.status_label.setAlignment(Qt.AlignCenter)
        self.status_label.setStyleSheet("""
            QLabel {
                color: #666;
                font-size: 14px;
                background-color: rgba(240, 240, 240, 180);
                border: 1px dashed #ccc;
                border-radius: 8px;
                padding: 40px;
                margin: 20px;
                min-height: 200px;
            }
        """)
        
        main_layout.addWidget(self.status_label)
        
        # åˆ›å»ºæµ®åŠ¨çš„å°å‹å…¨æ™¯å›¾
        self.floating_panorama = self._create_floating_panorama()
    
    def _create_floating_panorama(self):
        """åˆ›å»ºæµ®åŠ¨çš„å…¨æ™¯å›¾çª—å£"""
        # åˆ›å»ºæµ®åŠ¨å®¹å™¨
        floating_container = QWidget(self)
        floating_container.setFixedSize(220, 240)  # å¢åŠ é«˜åº¦ä»¥å®¹çº³æ ‡é¢˜
        floating_container.setStyleSheet("""
            QWidget {
                background-color: rgba(255, 255, 255, 0.85);
                border: none;
                border-radius: 8px;
            }
        """)
        
        # è®¾ç½®æµ®åŠ¨çª—å£çš„å±‚çº§å’Œé€æ˜åº¦
        floating_container.setWindowFlags(Qt.Widget)
        floating_container.setAttribute(Qt.WA_TranslucentBackground, False)
        floating_container.raise_()
        
        # åœ¨æµ®åŠ¨å®¹å™¨ä¸­æ·»åŠ æ ‡é¢˜å’Œå…¨æ™¯å›¾
        layout = QVBoxLayout(floating_container)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(5)
        
        # æ·»åŠ æ ‡é¢˜
        title_label = QLabel("å…¨å±€é¢„è§ˆè§†å›¾")
        title_label.setAlignment(Qt.AlignCenter)
        title_label.setStyleSheet("""
            QLabel {
                color: #333;
                font-size: 12px;
                font-weight: bold;
                background: transparent;
                border: none;
                padding: 3px;
            }
        """)
        layout.addWidget(title_label)
        
        # åˆ›å»ºå°å‹å…¨æ™¯å›¾ç»„ä»¶
        self.mini_panorama = self._create_mini_panorama()
        layout.addWidget(self.mini_panorama)
        
        # åˆå§‹å®šä½åˆ°å·¦ä¸Šè§’
        floating_container.move(10, 10)
        floating_container.show()
        
        return floating_container
    
    def connect_data_signals(self, main_window):
        """è¿æ¥ä¸»çª—å£çš„æ•°æ®æ›´æ–°ä¿¡å·"""
        print(f"ğŸ”— [ä¿¡å·è¿æ¥] å°è¯•è¿æ¥ä¸»çª—å£ä¿¡å·...")
        
        if hasattr(main_window, 'status_updated'):
            main_window.status_updated.connect(self.update_floating_panorama_hole_status)
            print(f"âœ… [ä¿¡å·è¿æ¥] å·²è¿æ¥ status_updated ä¿¡å·åˆ°æµ®åŠ¨å…¨æ™¯å›¾æ›´æ–°")
        else:
            print(f"âš ï¸ [ä¿¡å·è¿æ¥] ä¸»çª—å£æ²¡æœ‰ status_updated ä¿¡å·")
        
        # ä¹Ÿå°è¯•è¿æ¥å…¶ä»–å¯èƒ½çš„ä¿¡å·
        if hasattr(main_window, 'hole_status_changed'):
            main_window.hole_status_changed.connect(self.update_floating_panorama_hole_status)
            print(f"âœ… [ä¿¡å·è¿æ¥] å·²è¿æ¥ hole_status_changed ä¿¡å·")
        
        print(f"ğŸ”— [ä¿¡å·è¿æ¥] ä¿¡å·è¿æ¥å®Œæˆ")
    
    def update_floating_panorama_hole_status(self, hole_id: str, status):
        """æ›´æ–°æµ®åŠ¨å…¨æ™¯å›¾ä¸­çš„å­”ä½çŠ¶æ€ï¼ˆå¤ç”¨å·¦è¾¹æ é€»è¾‘ï¼‰"""
        print(f"ğŸ¨ [æµ®åŠ¨å…¨æ™¯å›¾] æ¥æ”¶åˆ°çŠ¶æ€æ›´æ–°ä¿¡å·: {hole_id} -> {status}")
        
        if hasattr(self, 'mini_panorama') and self.mini_panorama:
            self.update_mini_panorama_hole_status(hole_id, status)
        else:
            print(f"âš ï¸ [æµ®åŠ¨å…¨æ™¯å›¾] mini_panorama ä¸å­˜åœ¨ï¼Œæ— æ³•æ›´æ–°çŠ¶æ€")
    
    def resizeEvent(self, event):
        """å¤„ç†çª—å£å¤§å°å˜åŒ–äº‹ä»¶ï¼Œæ›´æ–°æµ®åŠ¨çª—å£ä½ç½®"""
        super().resizeEvent(event)
        if hasattr(self, 'floating_panorama') and self.floating_panorama:
            # ä¿æŒæµ®åŠ¨çª—å£åœ¨å·¦ä¸Šè§’
            self.floating_panorama.move(10, 10)
            self.floating_panorama.raise_()
    
    def _verify_transform_applied(self, expected_center_x: float, expected_center_y: float):
        """éªŒè¯å˜æ¢æ˜¯å¦æˆåŠŸåº”ç”¨"""
        try:
            # è·å–å½“å‰è§†å›¾ä¸­å¿ƒ
            view_center = self.graphics_view.mapToScene(self.graphics_view.viewport().rect().center())
            print(f"ğŸ” [å˜æ¢éªŒè¯] æœŸæœ›ä¸­å¿ƒ: ({expected_center_x}, {expected_center_y})")
            print(f"ğŸ” [å˜æ¢éªŒè¯] å®é™…ä¸­å¿ƒ: ({view_center.x()}, {view_center.y()})")
            
            # è®¡ç®—åå·®
            diff_x = abs(view_center.x() - expected_center_x)
            diff_y = abs(view_center.y() - expected_center_y)
            
            if diff_x > 10 or diff_y > 10:
                print(f"âš ï¸ [å˜æ¢éªŒè¯] åå·®è¾ƒå¤§: Xåå·®={diff_x}, Yåå·®={diff_y}")
                # å¦‚æœåå·®å¤§ï¼Œè¿”å›Falseè¡¨ç¤ºéœ€è¦é‡æ–°åº”ç”¨
                return False
            else:
                print(f"âœ… [å˜æ¢éªŒè¯] å˜æ¢æˆåŠŸåº”ç”¨")
                return True
        except Exception as e:
            print(f"âŒ [å˜æ¢éªŒè¯] éªŒè¯å¤±è´¥: {e}")
            return False
    
    def _reapply_transform_if_needed(self, transform: QTransform, expected_center_x: float, expected_center_y: float):
        """å¦‚æœå˜æ¢è¢«è¦†ç›–ï¼Œé‡æ–°åº”ç”¨"""
        if not self._verify_transform_applied(expected_center_x, expected_center_y):
            print(f"ğŸ”„ [å˜æ¢ä¿®å¤] æ£€æµ‹åˆ°å˜æ¢è¢«è¦†ç›–ï¼Œé‡æ–°åº”ç”¨")
            self.graphics_view.setTransform(transform)
            self.graphics_view.viewport().update()
    
    def _create_mini_panorama(self):
        """åˆ›å»ºå°å‹å…¨æ™¯å›¾ç»„ä»¶"""
        from PySide6.QtWidgets import QGraphicsView
        from PySide6.QtGui import QPainter
        
        mini_view = OptimizedGraphicsView()
        mini_view.setFrameStyle(QFrame.NoFrame)
        mini_view.setFixedSize(180, 180)  # å°å‹å°ºå¯¸
        
        # å¯ç”¨æŠ—é”¯é½¿å’Œå¹³æ»‘å˜æ¢
        mini_view.setRenderHint(QPainter.Antialiasing, True)
        mini_view.setRenderHint(QPainter.SmoothPixmapTransform, True)
        mini_view.setRenderHint(QPainter.TextAntialiasing, True)
        
        # ä½¿ç”¨å®Œæ•´è§†å£æ›´æ–°ç¡®ä¿æ­£ç¡®æ¸²æŸ“
        mini_view.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        
        # ç¦ç”¨ç¼“å­˜æ¨¡å¼ä»¥ç¡®ä¿å®æ—¶æ›´æ–°
        mini_view.setCacheMode(QGraphicsView.CacheNone)
        
        # éšè—æ»šåŠ¨æ¡
        from PySide6.QtCore import Qt
        mini_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        mini_view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # ç¦ç”¨æ‹–æ‹½å’Œç¼©æ”¾
        mini_view.setDragMode(QGraphicsView.NoDrag)
        mini_view.setInteractive(False)
        
        # è®¾ç½®èƒŒæ™¯é¢œè‰²
        from PySide6.QtGui import QBrush, QColor
        mini_view.setBackgroundBrush(QBrush(QColor(245, 245, 245)))
        
        # æ·»åŠ ç‚¹å‡»æ£€æµ‹ï¼ˆè™½ç„¶è®¾ç½®ä¸ºéäº¤äº’ï¼Œä½†æˆ‘ä»¬å¯ä»¥é‡å†™é¼ æ ‡äº‹ä»¶ï¼‰
        mini_view.mousePressEvent = self._mini_panorama_mouse_press
        
        return mini_view
    
    def _mini_panorama_mouse_press(self, event):
        """å°å‹å…¨æ™¯å›¾é¼ æ ‡ç‚¹å‡»äº‹ä»¶"""
        # å°†ç‚¹å‡»äº‹ä»¶å§”æ‰˜ç»™ä¸»å…¨æ™¯å›¾çš„ç‚¹å‡»å¤„ç†é€»è¾‘
        if hasattr(self, 'sector_graphics_manager') and self.sector_graphics_manager:
            view_pos = event.position().toPoint() if hasattr(event.position(), 'toPoint') else event.pos()
            scene_pos = self.mini_panorama.mapToScene(view_pos)
            
            # æ£€æµ‹ç‚¹å‡»çš„æ‰‡å½¢åŒºåŸŸ
            clicked_sector = self._detect_clicked_sector_mini(scene_pos)
            if clicked_sector:
                print(f"ğŸ–±ï¸ [å°å‹å…¨æ™¯å›¾] ç‚¹å‡»æ‰‡å½¢: {clicked_sector.value}")
                self.sector_changed.emit(clicked_sector)
    
    def _detect_clicked_sector_mini(self, scene_pos: QPointF) -> Optional[SectorQuadrant]:
        """æ£€æµ‹å°å‹å…¨æ™¯å›¾ä¸­ç‚¹å‡»çš„æ‰‡å½¢åŒºåŸŸ"""
        if not hasattr(self, 'center_point') or not self.center_point:
            return None
        
        # è®¡ç®—ç›¸å¯¹äºä¸­å¿ƒç‚¹çš„ä½ç½®
        dx = scene_pos.x() - self.center_point.x()
        dy = scene_pos.y() - self.center_point.y()
        
        # è®¡ç®—è·ç¦»ï¼Œç”¨äºéªŒè¯ç‚¹å‡»æ˜¯å¦åœ¨åœ†å½¢åŒºåŸŸå†…
        import math
        distance = math.sqrt(dx * dx + dy * dy)
        
        # è®¾ç½®æœ‰æ•ˆç‚¹å‡»è·ç¦»èŒƒå›´
        if hasattr(self, 'panorama_radius') and self.panorama_radius > 0:
            max_valid_distance = self.panorama_radius * 1.2
        else:
            max_valid_distance = 200  # é»˜è®¤å€¼
        
        if distance > max_valid_distance:
            return None
        
        # è®¡ç®—è§’åº¦
        angle_rad = math.atan2(dy, dx)
        angle_deg = math.degrees(angle_rad)
        
        # è½¬æ¢ä¸º0-360åº¦èŒƒå›´
        if angle_deg < 0:
            angle_deg += 360
        
        # æ ¹æ®è§’åº¦ç¡®å®šæ‰‡å½¢
        if 315 <= angle_deg or angle_deg < 45:
            return SectorQuadrant.SECTOR_1
        elif 45 <= angle_deg < 135:
            return SectorQuadrant.SECTOR_2
        elif 135 <= angle_deg < 225:
            return SectorQuadrant.SECTOR_3
        elif 225 <= angle_deg < 315:
            return SectorQuadrant.SECTOR_4
        
        return None
    
    def _setup_mini_panorama(self, hole_collection: HoleCollection):
        """è®¾ç½®å°å‹å…¨æ™¯å›¾æ•°æ®"""
        if not hasattr(self, 'mini_panorama') or not self.mini_panorama:
            return
        
        # åˆ›å»ºåœºæ™¯
        from PySide6.QtWidgets import QGraphicsScene
        from PySide6.QtGui import QBrush, QColor, QPen
        from PySide6.QtWidgets import QGraphicsEllipseItem
        
        scene = QGraphicsScene()
        self.mini_panorama.setScene(scene)
        
        # è®¡ç®—ä¸­å¿ƒç‚¹å’Œè¾¹ç•Œï¼Œå‘å³ä¸‹åç§»
        bounds = hole_collection.get_bounds()
        original_center_x = (bounds[0] + bounds[2]) / 2
        original_center_y = (bounds[1] + bounds[3] ) / 2
        
        # å°å‹å…¨æ™¯å›¾ä½¿ç”¨çœŸæ­£çš„ä¸­å¿ƒç‚¹ï¼ˆä¸åç§»ï¼‰ä»¥å‡†ç¡®æ˜¾ç¤ºæ•°æ®ç»“æ„
        self.center_point = QPointF(original_center_x, original_center_y)
        
        print(f"ğŸ¯ [å°å‹å…¨æ™¯å›¾] ä½¿ç”¨æ•°æ®å‡ ä½•ä¸­å¿ƒ: ({self.center_point.x():.1f}, {self.center_point.y():.1f})")
        
        # è®¡ç®—å…¨æ™¯å›¾åŠå¾„ï¼Œç¼©å°å°ºå¯¸
        width = bounds[2] - bounds[0]
        height = bounds[3] - bounds[1]
        self.panorama_radius = max(width, height) / 2 * 0.9  # ä»1.1æ”¹ä¸º0.9ï¼Œç¼©å°æ‰‡å½¢
        
        # æ·»åŠ æ‰€æœ‰å­”ä½åˆ°å°å‹å…¨æ™¯å›¾
        hole_count = 0
        for hole in hole_collection.holes.values():
            hole_item = QGraphicsEllipseItem(
                hole.center_x - hole.radius,
                hole.center_y - hole.radius,
                hole.radius * 2,
                hole.radius * 2
            )
            
            # è®¾ç½®åˆå§‹é¢œè‰²ï¼ˆç°è‰²ï¼‰
            hole_item.setBrush(QBrush(QColor(200, 200, 200)))
            hole_item.setPen(QPen(QColor(150, 150, 150), 0.5))
            
            # è®¾ç½®hole_idä½œä¸ºdataä»¥ä¾¿æ›´æ–°æ—¶æŸ¥æ‰¾
            hole_item.setData(0, hole.hole_id)
            
            scene.addItem(hole_item)
            hole_count += 1
        
        print(f"ğŸ¨ [å°å‹å…¨æ™¯å›¾] å·²åˆ›å»º {hole_count} ä¸ªå­”ä½å›¾å½¢é¡¹")
        
        # æ·»åŠ æ‰‡å½¢åˆ†å‰²çº¿
        self._add_sector_lines_to_mini_panorama(scene)
        
        # é€‚é…è§†å›¾
        scene_rect = scene.itemsBoundingRect()
        margin = max(scene_rect.width(), scene_rect.height()) * 0.1
        scene_rect.adjust(-margin, -margin, margin, margin)
        scene.setSceneRect(scene_rect)
        self.mini_panorama.fitInView(scene_rect, Qt.KeepAspectRatio)
    
    def _add_sector_lines_to_mini_panorama(self, scene):
        """æ·»åŠ æ‰‡å½¢åˆ†å‰²çº¿åˆ°å°å‹å…¨æ™¯å›¾"""
        from PySide6.QtWidgets import QGraphicsLineItem
        from PySide6.QtGui import QPen, QColor
        from PySide6.QtCore import Qt
        import math
        
        if not self.center_point or self.panorama_radius <= 0:
            return
        
        # åˆ›å»ºåˆ†å‰²çº¿çš„ç”»ç¬” - è¿›ä¸€æ­¥å¢å¼ºå¯è§æ€§
        pen = QPen(QColor(40, 40, 40), 3.0, Qt.SolidLine)
        
        # åå­—åˆ†å‰²çº¿ï¼ˆæ°´å¹³çº¿å’Œå‚ç›´çº¿ï¼‰
        
        # æ°´å¹³çº¿ï¼ˆåˆ†éš”ä¸Šä¸‹æ‰‡å½¢ï¼‰
        h_line = QGraphicsLineItem(
            self.center_point.x() - self.panorama_radius,
            self.center_point.y(),
            self.center_point.x() + self.panorama_radius,
            self.center_point.y()
        )
        h_line.setPen(pen)
        scene.addItem(h_line)
        
        # å‚ç›´çº¿ï¼ˆåˆ†éš”å·¦å³æ‰‡å½¢ï¼‰
        v_line = QGraphicsLineItem(
            self.center_point.x(),
            self.center_point.y() - self.panorama_radius,
            self.center_point.x(),
            self.center_point.y() + self.panorama_radius
        )
        v_line.setPen(pen)
        scene.addItem(v_line)
    
    def update_mini_panorama_hole_status(self, hole_id: str, status):
        """æ›´æ–°å°å‹å…¨æ™¯å›¾ä¸­çš„å­”ä½çŠ¶æ€ï¼ˆæ™ºèƒ½æ›´æ–°ç‰ˆæœ¬ï¼‰"""
        print(f"ğŸ¨ [å°å‹å…¨æ™¯å›¾] å°è¯•æ›´æ–°å­”ä½çŠ¶æ€: {hole_id} -> {status}")
        
        # æ£€æŸ¥mini_panoramaå±æ€§
        if not hasattr(self, 'mini_panorama'):
            print(f"âŒ [å°å‹å…¨æ™¯å›¾] æ²¡æœ‰ mini_panorama å±æ€§")
            return
            
        if not self.mini_panorama:
            print(f"âŒ [å°å‹å…¨æ™¯å›¾] mini_panorama ä¸º None")
            return
            
        # æ£€æŸ¥åœºæ™¯
        scene = getattr(self.mini_panorama, 'scene', None)
        if not scene:
            print(f"âŒ [å°å‹å…¨æ™¯å›¾] æ²¡æœ‰åœºæ™¯")
            return
            
        print(f"âœ… [å°å‹å…¨æ™¯å›¾] åœºæ™¯å­˜åœ¨ï¼Œç±»å‹: {type(scene)}")
        
        # æ£€æŸ¥æ˜¯å¦åœ¨æ¨¡æ‹ŸæœŸé—´
        is_simulation_running = self._check_simulation_status_for_mini()
        
        if is_simulation_running:
            # æ¨¡æ‹ŸæœŸé—´ï¼šç›´æ¥å®æ—¶æ›´æ–°
            print(f"ğŸ”¥ [å°å‹å…¨æ™¯å›¾] æ¨¡æ‹ŸæœŸé—´ï¼Œä½¿ç”¨å®æ—¶æ›´æ–°")
            self._apply_mini_immediate_update(hole_id, status)
        else:
            # æ­£å¸¸æœŸé—´ï¼šå¯ä»¥é€‚å½“å»¶è¿Ÿæ›´æ–°
            print(f"ğŸ“¦ [å°å‹å…¨æ™¯å›¾] æ­£å¸¸æœŸé—´ï¼Œä½¿ç”¨å¿«é€Ÿæ›´æ–°")
            self._apply_mini_immediate_update(hole_id, status)  # å°å‹å›¾å§‹ç»ˆä½¿ç”¨å¿«é€Ÿæ›´æ–°
    
    def _check_simulation_status_for_mini(self) -> bool:
        """æ£€æŸ¥æ¨¡æ‹ŸçŠ¶æ€ï¼ˆä¸“é—¨ç”¨äºå°å‹å…¨æ™¯å›¾ï¼‰"""
        try:
            # é€šè¿‡parentæ‰¾åˆ°ä¸»çª—å£
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'simulation_running'):
                main_window = main_window.parent()
            
            if main_window:
                simulation_v1 = getattr(main_window, 'simulation_running', False)
                simulation_v2 = getattr(main_window, 'simulation_running_v2', False)
                is_running = simulation_v1 or simulation_v2
                if is_running:
                    print(f"ğŸ¯ [å°å‹å…¨æ™¯å›¾] æ£€æµ‹åˆ°æ¨¡æ‹Ÿè¿è¡Œä¸­: V1={simulation_v1}, V2={simulation_v2}")
                return is_running
            return False
        except Exception as e:
            print(f"âŒ [å°å‹å…¨æ™¯å›¾] æ¨¡æ‹ŸçŠ¶æ€æ£€æŸ¥å¤±è´¥: {e}")
            return False
    
    def _apply_mini_immediate_update(self, hole_id: str, status):
        """ä½¿ç”¨ä¸CompletePanoramaWidgetç›¸åŒçš„å®æ—¶æ›´æ–°é€»è¾‘"""
        print(f"âš¡ [å°å‹å…¨æ™¯å›¾] å®æ—¶æ›´æ–°å­”ä½: {hole_id} -> {status.value if hasattr(status, 'value') else status}")
        
        try:
            # è·å–çŠ¶æ€é¢œè‰²æ˜ å°„ï¼ˆä¸CompletePanoramaWidgetä¿æŒä¸€è‡´ï¼‰
            from aidcis2.models.hole_data import HoleStatus
            from PySide6.QtGui import QColor, QBrush, QPen
            
            color_map = {
                HoleStatus.PENDING: QColor(200, 200, 200),      # ç°è‰²
                HoleStatus.QUALIFIED: QColor(76, 175, 80),      # ç»¿è‰²
                HoleStatus.DEFECTIVE: QColor(244, 67, 54),      # çº¢è‰²
                HoleStatus.PROCESSING: QColor(33, 150, 243),    # è“è‰²
                HoleStatus.BLIND: QColor(255, 193, 7),          # é»„è‰²
                HoleStatus.TIE_ROD: QColor(156, 39, 176)        # ç´«è‰²
            }
            
            # è½¬æ¢çŠ¶æ€
            if isinstance(status, str):
                try:
                    status = HoleStatus(status)
                except ValueError:
                    status = HoleStatus.PENDING
            
            color = color_map.get(status, QColor(200, 200, 200))
            print(f"ğŸ¨ [å°å‹å…¨æ™¯å›¾] çŠ¶æ€ {status} å¯¹åº”é¢œè‰²: RGB({color.red()}, {color.green()}, {color.blue()})")
            
            # mini_panorama æ˜¯ OptimizedGraphicsViewï¼Œéœ€è¦é€šè¿‡åœºæ™¯æŸ¥æ‰¾å›¾å½¢é¡¹
            if hasattr(self.mini_panorama, 'scene'):
                scene = self.mini_panorama.scene
                if scene:
                    items = scene.items()
                    print(f"  ğŸ“Š [å°å‹å…¨æ™¯å›¾] åœºæ™¯ä¸­æœ‰ {len(items)} ä¸ªå›¾å½¢é¡¹")
                    
                    # æŸ¥æ‰¾å¯¹åº”çš„å­”ä½å›¾å½¢é¡¹
                    found = False
                    for item in items:
                        # æ£€æŸ¥æ˜¯å¦é€šè¿‡ setData å­˜å‚¨äº† hole_id
                        item_hole_id = item.data(0)
                        if item_hole_id and item_hole_id == hole_id:
                            print(f"  ğŸ¯ [å°å‹å…¨æ™¯å›¾] æ‰¾åˆ°ç›®æ ‡å­”ä½: {hole_id}")
                            # æ›´æ–°é¢œè‰²
                            from PySide6.QtGui import QBrush, QPen
                            item.setBrush(QBrush(color))
                            item.setPen(QPen(color.darker(120), 0.5))
                            found = True
                            print(f"  âœ… [å°å‹å…¨æ™¯å›¾] çŠ¶æ€å·²æ›´æ–°")
                            # å¼ºåˆ¶åˆ·æ–°è¯¥é¡¹
                            item.update()
                            break
                    
                    if not found:
                        print(f"  âš ï¸ [å°å‹å…¨æ™¯å›¾] æœªæ‰¾åˆ°å­”ä½ {hole_id}")
                else:
                    print(f"  âŒ [å°å‹å…¨æ™¯å›¾] åœºæ™¯ä¸ºç©º")
            
            # å¦‚æœmini_panoramaæœ‰hole_itemså±æ€§ï¼ˆå…¼å®¹æ€§æ£€æŸ¥ï¼‰
            elif hasattr(self.mini_panorama, 'hole_items') and hole_id in self.mini_panorama.hole_items:
                hole_item = self.mini_panorama.hole_items[hole_id]
                hole_item.setBrush(QBrush(color))
                hole_item.setPen(QPen(color.darker(120), 1))
                
                # å¼ºåˆ¶ç«‹å³é‡ç»˜
                hole_item.update()
                self.mini_panorama.update()
                print(f"âœ… [å°å‹å…¨æ™¯å›¾] é€šè¿‡hole_itemså®æ—¶æ›´æ–°å®Œæˆ: {hole_id}")
            else:
                # å¤‡ç”¨æ–¹æ³•ï¼šé€šè¿‡åœºæ™¯é¡¹ç›®æœç´¢ï¼ˆåŸæœ‰æ–¹æ³•ï¼‰
                print(f"ğŸ” [å°å‹å…¨æ™¯å›¾] hole_itemsä¸­æœªæ‰¾åˆ°ï¼Œå°è¯•åœºæ™¯æœç´¢")
                
                # ä¿®å¤sceneè°ƒç”¨é”™è¯¯ï¼šsceneæ˜¯å±æ€§ï¼Œä¸æ˜¯æ–¹æ³•
                scene = getattr(self.mini_panorama, 'scene', None)
                if scene and hasattr(scene, 'items'):
                    scene_items = scene.items()
                    item_found = False
                    
                    for item in scene_items:
                        if hasattr(item, 'data') and item.data(0) == hole_id:
                            item.setBrush(QBrush(color))
                            item.setPen(QPen(color.darker(120), 1))
                            # å¼ºåˆ¶ç«‹å³é‡ç»˜
                            item.update()
                            print(f"âœ… [å°å‹å…¨æ™¯å›¾] é€šè¿‡åœºæ™¯æœç´¢å®æ—¶æ›´æ–°å®Œæˆ: {hole_id}")
                            item_found = True
                            break
                    
                    if not item_found:
                        print(f"âŒ [å°å‹å…¨æ™¯å›¾] æœªæ‰¾åˆ°å­”ä½å›¾å½¢é¡¹: {hole_id}")
                        # è¾“å‡ºè°ƒè¯•ä¿¡æ¯
                        total_items = len(scene_items) if scene_items else 0
                        has_hole_items = hasattr(self.mini_panorama, 'hole_items')
                        hole_items_count = len(self.mini_panorama.hole_items) if has_hole_items and self.mini_panorama.hole_items else 0
                        print(f"ğŸ” [å°å‹å…¨æ™¯å›¾] åœºæ™¯ä¸­å…±æœ‰ {total_items} ä¸ªå›¾å½¢é¡¹ï¼Œhole_items: {hole_items_count} ä¸ª")
                else:
                    print(f"âŒ [å°å‹å…¨æ™¯å›¾] åœºæ™¯å¯¹è±¡æ— æ•ˆæˆ–æ²¡æœ‰itemsæ–¹æ³•")
            
            # å¼ºåˆ¶åˆ·æ–°å°å‹å…¨æ™¯å›¾è§†å›¾ï¼ˆä¸CompletePanoramaWidgetä¿æŒä¸€è‡´ï¼‰
            self.mini_panorama.update()
            if hasattr(self.mini_panorama, 'viewport'):
                self.mini_panorama.viewport().update()
            
        except Exception as e:
            print(f"âŒ [å°å‹å…¨æ™¯å›¾] å®æ—¶æ›´æ–°å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
    
    def set_hole_collection(self, hole_collection: HoleCollection):
        """è®¾ç½®å­”ä½é›†åˆå¹¶åˆ›å»ºæ‰‡å½¢å›¾å½¢ç®¡ç†å™¨"""
        if hole_collection and len(hole_collection) > 0:
            # ä¿å­˜å®Œæ•´çš„å­”ä½é›†åˆä»¥ä¾›æ‰‡å½¢åˆ‡æ¢ä½¿ç”¨
            self.complete_hole_collection = hole_collection
            
            self.sector_graphics_manager = SectorGraphicsManager(hole_collection)
            
            # é¢„åˆ›å»ºæ‰€æœ‰æ‰‡å½¢è§†å›¾
            self._create_sector_views()
            
            # éšè—çŠ¶æ€æ ‡ç­¾ï¼Œæ˜¾ç¤ºå›¾å½¢å†…å®¹
            if hasattr(self, 'status_label'):
                self.status_label.hide()
            
            # è®¾ç½®å°å‹å…¨æ™¯å›¾æ•°æ®
            self._setup_mini_panorama(hole_collection)
            
            # å»¶è¿Ÿæ˜¾ç¤ºåˆå§‹æ‰‡å½¢ï¼Œç­‰å¾…è§†å›¾å®Œå…¨åˆå§‹åŒ–
            # è¿™æ ·å¯ä»¥ç¡®ä¿è§†å›¾å¤§å°æ­£ç¡®ï¼Œé¿å…å‰åç¼©æ”¾ä¸ä¸€è‡´
            self._wait_for_stable_size_and_switch()
        else:
            # æ²¡æœ‰æ•°æ®æ—¶æ˜¾ç¤ºçŠ¶æ€æ ‡ç­¾
            if hasattr(self, 'status_label'):
                self.status_label.setText("æ²¡æœ‰å¯æ˜¾ç¤ºçš„å­”ä½æ•°æ®")
                self.status_label.show()
    
    def _create_sector_views(self):
        """é¢„åˆ›å»ºæ‰€æœ‰æ‰‡å½¢åŒºåŸŸçš„å›¾å½¢è§†å›¾"""
        if not self.sector_graphics_manager:
            return
        
        for sector in SectorQuadrant:
            sector_collection = self.sector_graphics_manager.get_sector_collection(sector)
            if sector_collection and len(sector_collection) > 0:
                # ä¸ºè¯¥æ‰‡å½¢åˆ›å»ºç‹¬ç«‹çš„å›¾å½¢è§†å›¾ï¼ˆä¸æ˜¾ç¤ºï¼Œä»…é¢„å¤‡ï¼‰
                view = OptimizedGraphicsView()
                view.load_holes(sector_collection)
                view.switch_to_macro_view()
                
                self.sector_views[sector] = {
                    'view': view,
                    'collection': sector_collection,
                    'hole_count': len(sector_collection)
                }
    
    def _wait_for_stable_size_and_switch(self):
        """ç­‰å¾…è§†å›¾å¤§å°ç¨³å®šåå†åˆ‡æ¢æ‰‡å½¢"""
        self._size_check_count = 0
        self._last_size = None
        
        def check_and_switch():
            # è·å–å½“å‰è§†å›¾å¤§å°
            view_size = self.graphics_view.viewport().size()
            width = view_size.width()
            height = view_size.height()
            current_size = (width, height)
            
            # å¢åŠ æ£€æŸ¥è®¡æ•°
            self._size_check_count += 1
            
            # å¦‚æœè§†å›¾å¤ªå°ï¼ˆå¯èƒ½è¿˜åœ¨åˆå§‹åŒ–ï¼‰ï¼Œç»§ç»­ç­‰å¾…
            # ä½†æ˜¯ä¸è¦ç­‰å¾…å¤ªä¹…ï¼Œæœ€å¤šæ£€æŸ¥10æ¬¡ï¼ˆ0.5ç§’ï¼‰
            # é™ä½é˜ˆå€¼ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç¼©æ”¾ç®—æ³•å·²ç»èƒ½å¤„ç†å°è§†å›¾
            if (width < 300 or height < 200) and self._size_check_count < 10:
                print(f"â³ è§†å›¾å°ºå¯¸è¿‡å° ({width}x{height})ï¼Œç»§ç»­ç­‰å¾…... (æ£€æŸ¥ {self._size_check_count}/10)")
                QTimer.singleShot(50, check_and_switch)
            else:
                # å¦‚æœå¤§å°å·²ç»ç¨³å®šï¼ˆè¿ç»­ä¸¤æ¬¡ç›¸åŒï¼‰æˆ–è¶…è¿‡æœ€å¤§ç­‰å¾…æ¬¡æ•°
                if current_size == self._last_size or self._size_check_count >= 20:
                    print(f"âœ… è§†å›¾å°ºå¯¸ç¨³å®š ({width}x{height})ï¼Œåˆ‡æ¢åˆ°åˆå§‹æ‰‡å½¢")
                    self.switch_to_sector(self.current_sector)
                else:
                    # å¤§å°è¿˜åœ¨å˜åŒ–ï¼Œå†ç­‰ä¸€æ¬¡
                    self._last_size = current_size
                    if self._size_check_count < 30:  # æœ€å¤šç­‰å¾…1.5ç§’
                        QTimer.singleShot(50, check_and_switch)
                    else:
                        print(f"âš ï¸ è¾¾åˆ°æœ€å¤§ç­‰å¾…æ¬¡æ•°ï¼Œä½¿ç”¨å½“å‰å°ºå¯¸ ({width}x{height})")
                        self.switch_to_sector(self.current_sector)
        
        # å¼€å§‹æ£€æŸ¥
        QTimer.singleShot(50, check_and_switch)
    
    def switch_to_sector(self, sector: SectorQuadrant):
        """åˆ‡æ¢åˆ°æŒ‡å®šæ‰‡å½¢åŒºåŸŸæ˜¾ç¤º"""
        import time
        start_time = time.perf_counter()
        
        print(f"ğŸ”„ [æ‰‡å½¢åˆ‡æ¢] å¼€å§‹åˆ‡æ¢åˆ°: {sector.value}, åç§»é…ç½®: {self.sector_offset_ratio:.1%}, å¯ç”¨: {self.sector_offset_enabled}")
        
        if not self.sector_graphics_manager:
            print(f"âŒ [æ‰‡å½¢åˆ‡æ¢] sector_graphics_manager ä¸å­˜åœ¨")
            return
        
        self.current_sector = sector
        
        # è®¾ç½®æ ‡å¿—ï¼Œé˜²æ­¢è‡ªåŠ¨é€‚é…å’Œå¼ºåˆ¶å±…ä¸­å¹²æ‰°æ‰‡å½¢åç§»
        self.graphics_view.disable_auto_fit = True
        self.graphics_view.disable_auto_center = True
        
        # è·å–æ‰‡å½¢æ•°æ®
        sector_info = self.sector_views.get(sector)
        if not sector_info:
            # self.status_label.setText(f"æ‰‡å½¢ {sector.value} æš‚æ— æ•°æ®")
            return
        
        # å¦‚æœgraphics_viewè¿˜æ²¡æœ‰åŠ è½½å®Œæ•´çš„å­”ä½é›†åˆï¼Œå…ˆåŠ è½½å®Œæ•´æ•°æ®
        if not hasattr(self.graphics_view, 'hole_items') or not self.graphics_view.hole_items:
            if hasattr(self, 'complete_hole_collection') and self.complete_hole_collection:
                print(f"ğŸ”§ é¦–æ¬¡åŠ è½½å®Œæ•´å­”ä½é›†åˆ ({len(self.complete_hole_collection)} ä¸ªå­”ä½)")
                # ç¡®ä¿åœ¨åŠ è½½ä¹‹å‰è®¾ç½®æ ‡å¿—
                self.graphics_view.disable_auto_fit = True
                self.graphics_view.load_holes(self.complete_hole_collection)
                
                # åŒæ—¶åˆå§‹åŒ–å°å‹å…¨æ™¯å›¾çš„æ•°æ®ï¼ˆå¦‚æœè¿˜æ²¡æœ‰åˆå§‹åŒ–ï¼‰
                if hasattr(self, 'mini_panorama') and self.mini_panorama:
                    self._initialize_mini_panorama_data(self.complete_hole_collection)
        
        # æ˜¾ç¤º/éšè—å­”ä½ä»¥å®ç°æ‰‡å½¢ä¸“æ³¨æ˜¾ç¤º
        sector_collection = sector_info['collection']
        sector_hole_ids = set(hole.hole_id for hole in sector_collection.holes.values())
        
        # éšè—æ‰€æœ‰å­”ä½ï¼Œåªæ˜¾ç¤ºå½“å‰æ‰‡å½¢çš„å­”ä½
        total_hidden = 0
        total_shown = 0
        for hole_id, hole_item in self.graphics_view.hole_items.items():
            if hole_id in sector_hole_ids:
                hole_item.setVisible(True)
                total_shown += 1
            else:
                hole_item.setVisible(False)
                total_hidden += 1
        
        # é€‚åº”è§†å›¾åˆ°å½“å‰å¯è§çš„å­”ä½ - ä½¿ç”¨å¡«æ»¡ç­–ç•¥
        # æ³¨é‡Šæ‰ switch_to_macro_viewï¼Œå®ƒä¼šè¦†ç›–æˆ‘ä»¬çš„è®¾ç½®
        # self.graphics_view.switch_to_macro_view()
        
        # åªæ›´æ–°è§†å›¾æ¨¡å¼ï¼Œä¸è°ƒç”¨ä»»ä½•è‡ªåŠ¨è°ƒæ•´æ–¹æ³•
        self.graphics_view.current_view_mode = "macro"
        self.graphics_view.view_mode_changed.emit("macro")
        
        # ç›´æ¥è°ƒç”¨å¡«æ»¡ç­–ç•¥ï¼Œä¸ä½¿ç”¨å»¶è¿Ÿ
        self._apply_fill_view_strategy()
        
        # æ·»åŠ è°ƒè¯•æ—¥å¿—
        print(f"ğŸ”„ åˆ‡æ¢åˆ°æ‰‡å½¢ {sector.value}: æ˜¾ç¤º {total_shown} ä¸ªå­”ä½ï¼Œéšè— {total_hidden} ä¸ªå­”ä½")
        if len(sector_collection) > 0:
            bounds = sector_collection.get_bounds()
            print(f"ğŸ“ æ‰‡å½¢è¾¹ç•Œ: X=[{bounds[0]:.1f}, {bounds[2]:.1f}], Y=[{bounds[1]:.1f}, {bounds[3]:.1f}]")
        
        # æ›´æ–°æ ‡é¢˜å’ŒçŠ¶æ€ï¼ˆç§»é™¤ï¼Œå› ä¸ºå·²åˆ é™¤æ ‡é¢˜æ ï¼‰
        # sector_names = {
        #     SectorQuadrant.SECTOR_1: "åŒºåŸŸ1 (å³ä¸Š)",
        #     SectorQuadrant.SECTOR_2: "åŒºåŸŸ2 (å·¦ä¸Š)", 
        #     SectorQuadrant.SECTOR_3: "åŒºåŸŸ3 (å·¦ä¸‹)",
        #     SectorQuadrant.SECTOR_4: "åŒºåŸŸ4 (å³ä¸‹)"
        # }
        
        # self.title_label.setText(f"å½“å‰æ˜¾ç¤º: {sector_names[sector]}")
        # self.status_label.setText(f"æ˜¾ç¤º {sector_info['hole_count']} ä¸ªå­”ä½")
        
        # å‘å°„åˆ‡æ¢ä¿¡å·
        self.sector_changed.emit(sector)
        
        # ç»Ÿè®¡åˆ‡æ¢ç”¨æ—¶
        end_time = time.perf_counter()
        switch_duration = (end_time - start_time) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
        print(f"â±ï¸ æ‰‡å½¢ {sector.value} åˆ‡æ¢ç”¨æ—¶: {switch_duration:.2f}ms")
    
    def update_sector_progress(self, sector: SectorQuadrant, progress: SectorProgress):
        """æ›´æ–°æ‰‡å½¢è¿›åº¦ï¼ˆç¦ç”¨è‡ªåŠ¨åˆ‡æ¢ï¼Œç”±æ¨¡æ‹Ÿç³»ç»Ÿæ§åˆ¶ï¼‰"""
        # æ³¨é‡Šæ‰è‡ªåŠ¨åˆ‡æ¢é€»è¾‘ï¼Œæ”¹ä¸ºç”±æ‰‡å½¢é¡ºåºæ¨¡æ‹Ÿç³»ç»Ÿæ§åˆ¶
        # if progress.completed_holes > 0:
        #     self.switch_to_sector(sector)
        
        # åªæ›´æ–°è¿›åº¦æ•°æ®ï¼Œä¸è¿›è¡Œè§†å›¾åˆ‡æ¢
        # ä½¿ç”¨å‚æ•°é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
        _ = sector
        _ = progress
    
    def get_current_sector(self) -> SectorQuadrant:
        """è·å–å½“å‰æ˜¾ç¤ºçš„æ‰‡å½¢åŒºåŸŸ"""
        return self.current_sector
    
    def get_sector_info(self, sector: SectorQuadrant) -> Optional[Dict]:
        """è·å–æŒ‡å®šæ‰‡å½¢çš„ä¿¡æ¯"""
        return self.sector_views.get(sector)
    
    def _apply_fill_view_strategy(self):
        """åº”ç”¨å¡«æ»¡è§†å›¾ç­–ç•¥ - è®©æ‰‡å½¢çš„è§†è§‰ä¸­å¿ƒä¸è§†å›¾ä¸­å¿ƒå¯¹é½"""
        if not self.sector_graphics_manager or not self.sector_graphics_manager.center_point:
            # å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨è¾¹ç•Œæ¡†æ–¹æ³•
            self._apply_bbox_strategy()
            return
            
        # è·å–å®Œæ•´æ•°æ®çš„å‡ ä½•ä¸­å¿ƒç‚¹
        bounds = self.complete_hole_collection.get_bounds()
        original_center_x = (bounds[0] + bounds[2]) / 2
        original_center_y = (bounds[1] + bounds[3]) / 2
        
        # æ ¹æ®é…ç½®åº”ç”¨åç§»
        if self.sector_offset_enabled:
            offset_x = (bounds[2] - bounds[0]) * self.sector_offset_ratio  # å¯é…ç½®çš„å‘å³åç§»
            offset_y = 0  # åªå‘å³åç§»ï¼Œä¸å‘ä¸‹åç§»
            data_center_x = original_center_x + offset_x
            data_center_y = original_center_y + offset_y
            print(f"ğŸ¯ [åŠ¨æ€æ‰‡å½¢] ä½¿ç”¨åç§»åçš„æ•°æ®ä¸­å¿ƒ: ({data_center_x:.1f}, {data_center_y:.1f}), åç§»é‡: {self.sector_offset_ratio:.1%}")
        else:
            offset_x = 0
            offset_y = 0
            data_center_x = original_center_x
            data_center_y = original_center_y
            print(f"ğŸ¯ [åŠ¨æ€æ‰‡å½¢] ä½¿ç”¨çœŸæ­£çš„æ•°æ®å‡ ä½•ä¸­å¿ƒ: ({data_center_x:.1f}, {data_center_y:.1f})")
        
        data_center = QPointF(data_center_x, data_center_y)
        print(f"ğŸ“Š [åŠ¨æ€æ‰‡å½¢] åŸå§‹ä¸­å¿ƒ: ({original_center_x:.1f}, {original_center_y:.1f}), åç§»: ({offset_x:.1f}, {offset_y:.1f})")
        
        # è·å–å½“å‰æ‰‡å½¢çš„å¯è§å­”ä½
        visible_items = [item for item in self.graphics_view.hole_items.values() if item.isVisible()]
        
        if not visible_items:
            return
        
        # è®¡ç®—æ‰‡å½¢è¾¹ç•Œ
        min_x = min_y = float('inf')
        max_x = max_y = float('-inf')
        
        for item in visible_items:
            pos = item.pos()
            rect = item.boundingRect()
            min_x = min(min_x, pos.x() + rect.left())
            min_y = min(min_y, pos.y() + rect.top())
            max_x = max(max_x, pos.x() + rect.right())
            max_y = max(max_y, pos.y() + rect.bottom())
        
        # è®¡ç®—è¾¹ç•Œæ¡†ä¸­å¿ƒä½œä¸ºè§†è§‰ä¸­å¿ƒ
        # å¯¹äºæ‰‡å½¢æ•°æ®ï¼Œè¾¹ç•Œæ¡†ä¸­å¿ƒå°±æ˜¯æœ€åˆé€‚çš„è§†è§‰ä¸­å¿ƒ
        visual_center_x = (min_x + max_x) / 2
        visual_center_y = (min_y + max_y) / 2
        visual_center = QPointF(visual_center_x, visual_center_y)
        
        
        # è®¡ç®—æ‰‡å½¢å†…å®¹çš„å°ºå¯¸
        content_width = max_x - min_x
        content_height = max_y - min_y
        
        # è·å–è§†å›¾å°ºå¯¸
        view_rect = self.graphics_view.viewport().rect()
        view_width = view_rect.width()
        view_height = view_rect.height()
        
        # ç¡®ä¿è§†å›¾å¤§å°åˆç†ï¼Œé¿å…åˆå§‹åŒ–æ—¶çš„å°å°ºå¯¸å½±å“è®¡ç®—
        # æ€»æ˜¯ä½¿ç”¨åˆç†çš„æœ€å°å€¼ï¼Œç¡®ä¿æ‰‡å½¢æ˜¾ç¤ºè¶³å¤Ÿå¤§
        min_width = 700
        min_height = 500
        
        if view_width < min_width or view_height < min_height:
            print(f"âš ï¸ è§†å›¾å°ºå¯¸ ({view_width}x{view_height}) å°äºæœ€å°å€¼ï¼Œä½¿ç”¨é»˜è®¤å€¼ ({min_width}x{min_height})")
            view_width = max(view_width, min_width)
            view_height = max(view_height, min_height)
        
        print(f"ğŸ“ ä½¿ç”¨è§†å›¾å°ºå¯¸: {view_width}x{view_height}")
        
        # è®¡ç®—åŸºç¡€ç¼©æ”¾æ¯”ä¾‹
        scale_x = view_width / content_width if content_width > 0 else 1.0
        scale_y = view_height / content_height if content_height > 0 else 1.0
        base_scale = min(scale_x, scale_y)
        
        # æ ¹æ®è§†å›¾å¤§å°åŠ¨æ€è°ƒæ•´ç¼©æ”¾
        # ä½¿ç”¨sigmoidå‡½æ•°å®ç°å¹³æ»‘è¿‡æ¸¡
        view_size = min(view_width, view_height)
        
        # å½’ä¸€åŒ–è§†å›¾å¤§å°ï¼ˆå‡è®¾å¸¸è§èŒƒå›´æ˜¯300-1000åƒç´ ï¼‰
        normalized_size = (view_size - 300) / 700
        normalized_size = max(0, min(1, normalized_size))  # é™åˆ¶åœ¨0-1èŒƒå›´
        
        # ä½¿ç”¨sigmoidå‡½æ•°è®¡ç®—è‡ªé€‚åº”å› å­
        # å°è§†å›¾æ—¶è¾¹è·æ›´å¤§ï¼ˆ0.65ï¼‰ï¼Œå¤§è§†å›¾æ—¶è¾¹è·æ›´å°ï¼ˆ0.85ï¼‰
        import math
        adaptive_margin = 0.65 + 0.2 / (1 + math.exp(-6 * (normalized_size - 0.5)))
        
        # æ ¹æ®å†…å®¹å¯†åº¦è°ƒæ•´
        # è®¡ç®—å†…å®¹å¡«å……ç‡ï¼ˆå†…å®¹é¢ç§¯ä¸è§†å›¾é¢ç§¯çš„æ¯”ä¾‹ï¼‰
        content_area = content_width * content_height
        view_area = view_width * view_height
        fill_ratio = content_area / view_area if view_area > 0 else 1.0
        
        # å†…å®¹å¯†åº¦è¶Šé«˜ï¼Œéœ€è¦çš„è¾¹è·è¶Šå°
        density_factor = 1.0 + 0.25 * (1 - math.exp(-2 * fill_ratio))
        
        # æœ€ç»ˆç¼©æ”¾
        scale = base_scale * adaptive_margin * density_factor
        
        # é™åˆ¶ç¼©æ”¾èŒƒå›´
        scale = max(0.1, min(5.0, scale))
        
        print(f"ğŸ“Š è‡ªé€‚åº”ç¼©æ”¾: è§†å›¾{view_size:.0f}px, è¾¹è·ç³»æ•°{adaptive_margin:.2f}, å¯†åº¦ç³»æ•°{density_factor:.2f}")
        
        # é‡ç½®å˜æ¢
        self.graphics_view.resetTransform()
        
        # åº”ç”¨ç¼©æ”¾
        self.graphics_view.scale(scale, scale)
        
        # ä½¿ç”¨æ›´ç›´æ¥çš„æ–¹æ³•ï¼šè®¡ç®—è§†å›¾åº”è¯¥æ˜¾ç¤ºçš„åŒºåŸŸ
        view_width = self.graphics_view.viewport().width() / scale
        view_height = self.graphics_view.viewport().height() / scale
        
        # è®¡ç®—ä»¥visual_centerä¸ºä¸­å¿ƒçš„è§†å›¾çŸ©å½¢
        view_rect = QRectF(
            visual_center_x - view_width / 2,
            visual_center_y - view_height / 2,
            view_width,
            view_height
        )
        
        # è®¾ç½®åœºæ™¯çŸ©å½¢ï¼Œè¿™ä¼šå¼ºåˆ¶è§†å›¾æ˜¾ç¤ºè¿™ä¸ªåŒºåŸŸ
        self.graphics_view.setSceneRect(view_rect)
        
        # ç¦ç”¨è‡ªåŠ¨å±…ä¸­å’Œè‡ªåŠ¨é€‚é…ï¼Œé˜²æ­¢å˜æ¢è¢«è¦†ç›–
        self.graphics_view.disable_auto_center = True
        self.graphics_view.disable_auto_fit = True
        
        # åº”ç”¨åç§»æ•ˆæœè€Œä¸ä½¿ç”¨fitInViewï¼ˆé¿å…å¼ºåˆ¶å±…ä¸­ï¼‰
        # è®¾ç½®å˜æ¢ä»¥æ˜¾ç¤ºåç§»åçš„è§†å›¾åŒºåŸŸ
        transform = QTransform()
        transform.scale(scale, scale)
        transform.translate(-visual_center_x, -visual_center_y)
        self.graphics_view.setTransform(transform)
        
        # å¼ºåˆ¶åˆ·æ–°ç¡®ä¿å˜æ¢ç”Ÿæ•ˆ
        self.graphics_view.resetCachedContent()
        self.graphics_view.viewport().update()
        
        print(f"âœ… æ‰‡å½¢å·²åº”ç”¨åç§»æ˜¾ç¤ºï¼Œç¼©æ”¾: {scale:.2f}x, åç§»ä¸­å¿ƒ: ({visual_center_x:.1f}, {visual_center_y:.1f})")
        
        # å»¶è¿ŸéªŒè¯å’Œé‡æ–°åº”ç”¨ï¼Œé˜²æ­¢è¢«å…¶ä»–æ“ä½œè¦†ç›–
        QTimer.singleShot(100, lambda: self._verify_transform_applied(visual_center_x, visual_center_y))
        QTimer.singleShot(200, lambda: self._reapply_transform_if_needed(transform, visual_center_x, visual_center_y))
        QTimer.singleShot(500, lambda: self._reapply_transform_if_needed(transform, visual_center_x, visual_center_y))
        
        # ä¿æŠ¤æˆ‘ä»¬çš„è®¾ç½®ä¸è¢«åç»­æ“ä½œè¦†ç›–
        # ä¿å­˜å½“å‰è®¾ç½®
        self._sector_view_settings = {
            'scale': scale,
            'scene_rect': view_rect,
            'visual_center': visual_center
        }
        
        # å¤šæ¬¡å»¶è¿Ÿä¿æŠ¤ï¼Œç¡®ä¿è®¾ç½®ä¸è¢«è¦†ç›–
        for delay in [10, 50, 100, 200, 500]:
            QTimer.singleShot(delay, self._enforce_sector_settings)
    
    def _enforce_sector_settings(self):
        """å¼ºåˆ¶åº”ç”¨æ‰‡å½¢è§†å›¾è®¾ç½®"""
        if not hasattr(self, '_sector_view_settings'):
            return
            
        settings = self._sector_view_settings
        current_scale = self.graphics_view.transform().m11()
        
        # å¦‚æœç¼©æ”¾è¢«æ”¹å˜ï¼Œæ¢å¤è®¾ç½®
        if abs(current_scale - settings['scale']) > 0.01:
            print(f"âš ï¸ æ£€æµ‹åˆ°ç¼©æ”¾è¢«æ”¹å˜: {current_scale:.3f} -> {settings['scale']:.3f}ï¼Œå¼ºåˆ¶æ¢å¤")
            
            # é‡ç½®å¹¶åº”ç”¨ä¿å­˜çš„è®¾ç½®
            self.graphics_view.resetTransform()
            self.graphics_view.scale(settings['scale'], settings['scale'])
            self.graphics_view.setSceneRect(settings['scene_rect'])
            self.graphics_view.fitInView(settings['scene_rect'], Qt.KeepAspectRatio)
    
    def _apply_bbox_strategy(self):
        """å¤‡ç”¨ç­–ç•¥ï¼šä½¿ç”¨è¾¹ç•Œæ¡†æ–¹æ³•"""
        visible_items = [item for item in self.graphics_view.hole_items.values() if item.isVisible()]
        
        if not visible_items:
            return
            
        # è®¡ç®—å¯è§å­”ä½çš„è¾¹ç•Œ
        min_x = min_y = float('inf')
        max_x = max_y = float('-inf')
        
        for item in visible_items:
            pos = item.pos()
            rect = item.boundingRect()
            min_x = min(min_x, pos.x() + rect.left())
            min_y = min(min_y, pos.y() + rect.top())
            max_x = max(max_x, pos.x() + rect.right())
            max_y = max(max_y, pos.y() + rect.bottom())
        
        # åˆ›å»ºå¯è§å†…å®¹çš„è¾¹ç•ŒçŸ©å½¢
        visible_rect = QRectF(min_x, min_y, max_x - min_x, max_y - min_y)
        
        # æ·»åŠ é€‚å½“è¾¹è·
        margin = 20
        target_rect = visible_rect.adjusted(-margin, -margin, margin, margin)
        
        # ä½¿ç”¨fitInViewè®©æ‰‡å½¢å†…å®¹å¡«æ»¡è§†å›¾
        self.graphics_view.fitInView(target_rect, Qt.KeepAspectRatio)
        
        print(f"ğŸ” [å¤‡ç”¨] è¾¹ç•Œæ¡†è§†å›¾è°ƒæ•´: ({min_x:.1f}, {min_y:.1f}) - ({max_x:.1f}, {max_y:.1f})")


    def _initialize_mini_panorama_data(self, hole_collection):
        """åˆå§‹åŒ–å°å‹å…¨æ™¯å›¾çš„æ•°æ®"""
        print(f"ğŸ”„ [å°å‹å…¨æ™¯å›¾] åˆå§‹åŒ–æ•°æ®ï¼Œå…± {len(hole_collection)} ä¸ªå­”ä½")
        
        if not self.mini_panorama:
            print(f"âŒ [å°å‹å…¨æ™¯å›¾] mini_panorama ä¸å­˜åœ¨")
            return
            
        # ç¡®ä¿æœ‰åœºæ™¯
        if not hasattr(self.mini_panorama, 'scene') or not self.mini_panorama.scene:
            from PySide6.QtWidgets import QGraphicsScene
            scene = QGraphicsScene()
            self.mini_panorama.setScene(scene)
            print(f"âœ… [å°å‹å…¨æ™¯å›¾] åˆ›å»ºæ–°åœºæ™¯")
        
        scene = self.mini_panorama.scene
        
        # æ¸…ç©ºç°æœ‰å†…å®¹
        scene.clear()
        
        # åˆ›å»ºæ‰€æœ‰å­”ä½çš„å›¾å½¢é¡¹
        from PySide6.QtWidgets import QGraphicsEllipseItem
        from PySide6.QtGui import QBrush, QPen, QColor
        
        hole_count = 0
        for hole in hole_collection:
            # åˆ›å»ºç®€å•çš„åœ†å½¢è¡¨ç¤º
            hole_item = QGraphicsEllipseItem(
                hole.center_x - hole.radius,
                hole.center_y - hole.radius,
                hole.radius * 2,
                hole.radius * 2
            )
            
            # è®¾ç½®åˆå§‹é¢œè‰²ï¼ˆç°è‰²ï¼‰
            hole_item.setBrush(QBrush(QColor(200, 200, 200)))
            hole_item.setPen(QPen(QColor(150, 150, 150), 0.5))
            
            # è®¾ç½®hole_idä½œä¸ºdataä»¥ä¾¿æ›´æ–°æ—¶æŸ¥æ‰¾
            hole_item.setData(0, hole.hole_id)
            
            scene.addItem(hole_item)
            hole_count += 1
        
        print(f"ğŸ¨ [å°å‹å…¨æ™¯å›¾] å·²åˆ›å»º {hole_count} ä¸ªå­”ä½å›¾å½¢é¡¹")
        
        # è®¾ç½®åœºæ™¯è¾¹ç•Œ
        bounds = hole_collection.get_bounds()
        margin = 50
        scene_rect = QRectF(
            bounds[0] - margin, bounds[1] - margin,
            bounds[2] - bounds[0] + 2 * margin,
            bounds[3] - bounds[1] + 2 * margin
        )
        scene.setSceneRect(scene_rect)
        
        # é€‚åº”è§†å›¾
        self.mini_panorama.fitInView(scene_rect, Qt.KeepAspectRatio)
        print(f"ğŸ“ [å°å‹å…¨æ™¯å›¾] è§†å›¾å·²é€‚é…")


class CompletePanoramaWidget(QWidget):
    """å®Œæ•´å…¨æ™¯å›¾æ˜¾ç¤ºç»„ä»¶"""
    
    # æ·»åŠ ä¿¡å·ç”¨äºæ‰‡å½¢åŒºåŸŸç‚¹å‡»
    sector_clicked = Signal(SectorQuadrant)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.hole_collection: Optional[HoleCollection] = None
        self.center_point: Optional[QPointF] = None
        self.panorama_radius: float = 0.0
        self.sector_highlights: Dict[SectorQuadrant, SectorHighlightItem] = {}
        self.current_highlighted_sector: Optional[SectorQuadrant] = None
        
        # å»¶è¿Ÿæ‰¹é‡æ›´æ–°æœºåˆ¶
        self.pending_status_updates: Dict[str, any] = {}  # hole_id -> status
        self.batch_update_timer = QTimer()
        self.batch_update_timer.timeout.connect(self._apply_batch_updates)
        self.batch_update_timer.setSingleShot(True)
        self.batch_update_interval = 2000  # 2000æ¯«ç§’é—´éš”ï¼Œé™ä½æ¸²æŸ“é¢‘ç‡é¿å…é˜»å¡
        
        self.setup_ui()
    
    def setup_ui(self):
        """è®¾ç½®ç”¨æˆ·ç•Œé¢"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # ç§»é™¤æ ‡é¢˜ï¼Œç›´æ¥æ˜¾ç¤ºå…¨æ™¯å›¾å½¢è§†å›¾
        # title_label = QLabel("å®Œæ•´å­”ä½å…¨æ™¯å›¾")
        # title_label.setAlignment(Qt.AlignCenter)
        # title_label.setFont(QFont("Arial", 12, QFont.Bold))
        # title_label.setStyleSheet("padding: 5px; background-color: #e3f2fd; border-radius: 3px;")
        # layout.addWidget(title_label)
        
        # å…¨æ™¯å›¾å½¢è§†å›¾ - å›ºå®šå°ºå¯¸ç¡®ä¿å¸ƒå±€ä¸€è‡´æ€§
        self.panorama_view = OptimizedGraphicsView()
        self.panorama_view.setFrameStyle(QFrame.NoFrame)  # ç§»é™¤è¾¹æ¡†é¿å…é»‘æ¡†
        self.panorama_view.setFixedSize(350, 350)    # è°ƒæ•´æ˜¾ç¤ºé¢æ¿å°ºå¯¸é€‚é…380pxå®½åº¦
        
        # ä¸ºå…¨æ™¯å›¾ä¼˜åŒ–æ¸²æŸ“è®¾ç½® - éœ€è¦ä¸ä¸»è§†å›¾ä¸åŒçš„è®¾ç½®
        from PySide6.QtWidgets import QGraphicsView
        from PySide6.QtGui import QPainter
        
        # å¯ç”¨æŠ—é”¯é½¿å’Œå¹³æ»‘å˜æ¢ä»¥æ”¹å–„å…¨æ™¯å›¾æ˜¾ç¤ºè´¨é‡
        self.panorama_view.setRenderHint(QPainter.Antialiasing, True)
        self.panorama_view.setRenderHint(QPainter.SmoothPixmapTransform, True)
        self.panorama_view.setRenderHint(QPainter.TextAntialiasing, True)
        
        # ä½¿ç”¨å®Œæ•´è§†å£æ›´æ–°ç¡®ä¿æ­£ç¡®æ¸²æŸ“
        self.panorama_view.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        
        # ç¦ç”¨ç¼“å­˜æ¨¡å¼ä»¥ç¡®ä¿å®æ—¶æ›´æ–°
        self.panorama_view.setCacheMode(QGraphicsView.CacheNone)
        
        # è®¾ç½®ä¼˜åŒ–æ ‡å¿—ä»¥å¹³è¡¡æ€§èƒ½å’Œè´¨é‡
        self.panorama_view.setOptimizationFlag(QGraphicsView.DontSavePainterState, False)
        self.panorama_view.setOptimizationFlag(QGraphicsView.DontAdjustForAntialiasing, False)
        
        # éšè—æ»šåŠ¨æ¡
        self.panorama_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.panorama_view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # ç§»é™¤ç¡¬ç¼–ç æ ·å¼ï¼Œä½¿ç”¨ä¸»é¢˜ç®¡ç†å™¨
        self.panorama_view.setObjectName("PanoramaGraphicsView")
        
        # å¯ç”¨é¼ æ ‡è·Ÿè¸ªä»¥æ”¯æŒç‚¹å‡»æ‰‡å½¢åŒºåŸŸ
        self.panorama_view.setMouseTracking(True)
        
        # å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨æ¥æ‹¦æˆªé¼ æ ‡ç‚¹å‡»äº‹ä»¶
        self.panorama_view.viewport().installEventFilter(self)
        
        
        # åˆ›å»ºå…¨æ™¯å›¾å®¹å™¨ä»¥å®ç°å®Œå…¨å±…ä¸­ï¼ˆæ°´å¹³+å‚ç›´ï¼‰
        panorama_container = QWidget()
        panorama_layout = QVBoxLayout(panorama_container)
        panorama_layout.setContentsMargins(0, 0, 0, 0)
        panorama_layout.addStretch()  # ä¸Šæ–¹å¼¹æ€§ç©ºé—´
        
        # æ°´å¹³å±…ä¸­å¸ƒå±€
        h_container = QWidget()
        h_layout = QHBoxLayout(h_container)
        h_layout.setContentsMargins(0, 0, 0, 0)
        h_layout.addStretch()  # å·¦ä¾§å¼¹æ€§ç©ºé—´
        h_layout.addWidget(self.panorama_view)
        h_layout.addStretch()  # å³ä¾§å¼¹æ€§ç©ºé—´
        
        panorama_layout.addWidget(h_container)
        panorama_layout.addStretch()  # ä¸‹æ–¹å¼¹æ€§ç©ºé—´
        
        layout.addWidget(panorama_container)
        
        # ä¿¡æ¯æ ‡ç­¾ - æ”¾åœ¨å…¨æ™¯å›¾ä¸‹æ–¹ï¼Œå¢å¤§å­—ä½“
        self.info_label = QLabel("ç­‰å¾…æ•°æ®åŠ è½½...")
        self.info_label.setAlignment(Qt.AlignCenter)
        self.info_label.setStyleSheet("""
            QLabel {
                padding: 8px;
                font-size: 14px;
                font-weight: bold;
                color: #333;
                background-color: rgba(248, 249, 250, 200);
                border: 1px solid #ddd;
                border-radius: 6px;
                margin: 5px;
            }
        """)
        layout.addWidget(self.info_label)
    
    def load_complete_view(self, hole_collection: HoleCollection):
        """åŠ è½½å®Œæ•´çš„å…¨æ™¯å›¾"""
        if hole_collection and len(hole_collection) > 0:
            try:
                print(f"ğŸ”„ [å…¨æ™¯å›¾] å¼€å§‹åŠ è½½ {len(hole_collection)} ä¸ªå­”ä½")
                
                # åŠ è½½å­”ä½æ•°æ®åˆ°å…¨æ™¯è§†å›¾
                self.panorama_view.load_holes(hole_collection)
                print(f"âœ… [å…¨æ™¯å›¾] å­”ä½æ•°æ®å·²åŠ è½½åˆ°è§†å›¾")
                
                # åˆ‡æ¢åˆ°å®è§‚è§†å›¾
                self.panorama_view.switch_to_macro_view()
                print(f"ğŸ” [å…¨æ™¯å›¾] å·²åˆ‡æ¢åˆ°å®è§‚è§†å›¾")
                
                # ä¿å­˜æ•°æ®å¼•ç”¨
                self.hole_collection = hole_collection
                
                # å»¶è¿Ÿæ‰§è¡Œé€‚åº”è§†å›¾ï¼Œç¡®ä¿æ¸²æŸ“å®Œæˆ
                from PySide6.QtCore import QTimer
                QTimer.singleShot(50, self._setup_panorama_fitting)
                QTimer.singleShot(100, self._calculate_panorama_geometry)  # å…ˆè®¡ç®—å‡ ä½•ä¿¡æ¯
                QTimer.singleShot(150, self._fit_panorama_view)
                QTimer.singleShot(200, self._create_sector_highlights)  # åˆ›å»ºæ‰‡å½¢é«˜äº®
                
                # æ›´æ–°ä¿¡æ¯ - ä»å®é™…æ•°æ®ä¸­è¯»å–å­”ä½æ•°é‡
                actual_hole_count = len(hole_collection.holes) if hasattr(hole_collection, 'holes') else len(hole_collection)
                self.info_label.setText(f"å…¨æ™¯: {actual_hole_count} ä¸ªå­”ä½")
                print(f"ğŸ“Š [å…¨æ™¯å›¾] æ˜¾ç¤ºä¿¡æ¯å·²æ›´æ–°: {actual_hole_count} ä¸ªå­”ä½")
                
                # éªŒè¯åœºæ™¯å†…å®¹
                scene = self.panorama_view.scene
                if scene:
                    items_count = len(scene.items())
                    scene_rect = scene.sceneRect()
                    print(f"ğŸ“ [å…¨æ™¯å›¾] åœºæ™¯ä¿¡æ¯: {items_count} ä¸ªå›¾å½¢é¡¹, è¾¹ç•Œ: {scene_rect}")
                    
                    if items_count == 0:
                        print("âš ï¸ [å…¨æ™¯å›¾] è­¦å‘Š: åœºæ™¯ä¸­æ²¡æœ‰å›¾å½¢é¡¹!")
                    
            except Exception as e:
                print(f"âŒ [å…¨æ™¯å›¾] åŠ è½½å¤±è´¥: {e}")
                import traceback
                traceback.print_exc()
                self.info_label.setText(f"åŠ è½½å¤±è´¥: {str(e)}")
        else:
            self.info_label.setText("æš‚æ— æ•°æ®")
            print("ğŸ“­ [å…¨æ™¯å›¾] æ²¡æœ‰æ•°æ®å¯åŠ è½½")
    
    def _setup_panorama_fitting(self):
        """è®¾ç½®å…¨æ™¯å›¾é€‚åº”å‰çš„å‡†å¤‡å·¥ä½œ"""
        try:
            # ç¡®ä¿åœºæ™¯é¡¹ç›®å¯è§æ€§è®¾ç½®æ­£ç¡®
            scene = self.panorama_view.scene
            if scene:
                for item in scene.items():
                    item.setVisible(True)
                    item.update()
                
                # æ›´æ–°åœºæ™¯è¾¹ç•Œ
                scene.setSceneRect(scene.itemsBoundingRect())
                
                print(f"ğŸ”§ [å…¨æ™¯å›¾] åœºæ™¯è®¾ç½®å®Œæˆï¼Œé¡¹ç›®æ•°: {len(scene.items())}")
            
        except Exception as e:
            print(f"âš ï¸ [å…¨æ™¯å›¾] åœºæ™¯è®¾ç½®å¤±è´¥: {e}")
    
    def _fit_panorama_view(self):
        """å»¶è¿Ÿé€‚åº”å…¨æ™¯è§†å›¾ - ç¡®ä¿å†…å®¹å®Œç¾å±…ä¸­æ˜¾ç¤º"""
        try:
            scene = self.panorama_view.scene
            if scene and len(scene.items()) > 0:
                # è·å–åœºæ™¯å†…å®¹è¾¹ç•Œ
                scene_rect = scene.itemsBoundingRect()
                
                # é‡ç½®å˜æ¢çŸ©é˜µ
                self.panorama_view.resetTransform()
                
                # ä½¿ç”¨Qtçš„fitInViewæ¥ç¡®ä¿å®Œç¾å±…ä¸­å’Œé€‚åº”
                view_rect = self.panorama_view.viewport().rect()
                
                # è®¡ç®—é€‚å½“çš„è¾¹è·
                margin_x = scene_rect.width() * 0.05
                margin_y = scene_rect.height() * 0.05
                
                # åˆ›å»ºå¸¦è¾¹è·çš„ç›®æ ‡åŒºåŸŸ
                target_rect = QRectF(
                    scene_rect.x() - margin_x,
                    scene_rect.y() - margin_y,
                    scene_rect.width() + 2 * margin_x,
                    scene_rect.height() + 2 * margin_y
                )
                
                # ä½¿ç”¨fitInViewç¡®ä¿å†…å®¹å±…ä¸­ä¸”é€‚åº”è§†å›¾
                self.panorama_view.fitInView(target_rect, Qt.KeepAspectRatio)
                
                # è·å–å†…å®¹çš„å®é™…ä¸­å¿ƒç‚¹
                content_center = scene_rect.center()
                
                # å¤šæ¬¡å¼ºåˆ¶å±…ä¸­ä»¥ç¡®ä¿ç²¾ç¡®å¯¹é½
                from PySide6.QtCore import QTimer
                QTimer.singleShot(10, lambda: self.panorama_view.centerOn(content_center))
                QTimer.singleShot(50, lambda: self.panorama_view.centerOn(content_center))
                QTimer.singleShot(100, lambda: self.panorama_view.centerOn(content_center))
                
                print(f"ğŸ¯ [å…¨æ™¯å›¾] ä½¿ç”¨fitInViewå±…ä¸­å®Œæˆ")
                print(f"ğŸ“ [å…¨æ™¯å›¾] å†…å®¹ä¸­å¿ƒ: ({content_center.x():.1f}, {content_center.y():.1f})")
                print(f"ğŸ“ [å…¨æ™¯å›¾] å†…å®¹è¾¹ç•Œ: ({scene_rect.x():.1f}, {scene_rect.y():.1f}, {scene_rect.width():.1f}, {scene_rect.height():.1f})")
                print(f"ğŸ“º [å…¨æ™¯å›¾] è§†å›¾å°ºå¯¸: {view_rect.width()}x{view_rect.height()}")
            else:
                # å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨åŸå§‹é€‚åº”æ–¹æ³•
                self.panorama_view.fit_in_view()
                print("ğŸ¯ [å…¨æ™¯å›¾] è§†å›¾é€‚åº”å®Œæˆï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰")
            
            # å¼ºåˆ¶å¤šæ¬¡åˆ·æ–°ä»¥ç¡®ä¿æ¸²æŸ“
            for _ in range(3):
                self.panorama_view.viewport().update()
                self.panorama_view.update()
                self.panorama_view.scene.update()
            
            # é¢å¤–çš„æ¸²æŸ“å¼ºåˆ¶åˆ·æ–°
            from PySide6.QtCore import QTimer
            QTimer.singleShot(50, lambda: self.panorama_view.viewport().repaint())
            QTimer.singleShot(100, lambda: self.panorama_view.update())
            
            print("ğŸ”„ [å…¨æ™¯å›¾] å¼ºåˆ¶æ¸²æŸ“åˆ·æ–°å®Œæˆ")
            
        except Exception as e:
            print(f"âš ï¸ [å…¨æ™¯å›¾] é€‚åº”è§†å›¾å¤±è´¥: {e}")
    
    def _calculate_adaptive_scale(self, scene_rect):
        """åŸºäºå†…å®¹å°ºå¯¸åŠ¨æ€è®¡ç®—è‡ªé€‚åº”ç¼©æ”¾æ¯”ä¾‹"""
        try:
            # è·å–è§†å›¾çš„å¯ç”¨ç©ºé—´
            view_rect = self.panorama_view.viewport().rect()
            view_width = view_rect.width()
            view_height = view_rect.height()
            
            # è·å–åœºæ™¯å†…å®¹çš„å°ºå¯¸
            scene_width = scene_rect.width()
            scene_height = scene_rect.height()
            
            if scene_width <= 0 or scene_height <= 0:
                return 0.5
            
            # è®¡ç®—å†…å®¹ä¸è§†å›¾çš„å°ºå¯¸æ¯”ä¾‹
            width_ratio = scene_width / view_width
            height_ratio = scene_height / view_height
            content_size_ratio = max(width_ratio, height_ratio)
            
            # ä½¿ç”¨è¿ç»­å‡½æ•°åŠ¨æ€è®¡ç®—è¾¹è·å› å­ (0.8-0.95)
            # å†…å®¹è¶Šå°ï¼Œè¾¹è·è¶Šå¤§ï¼›å†…å®¹è¶Šå¤§ï¼Œè¾¹è·è¶Šå°
            import math
            margin_factor = 0.95 - 0.15 * min(1.0, content_size_ratio / 4.0)
            margin_factor = max(0.8, min(0.95, margin_factor))
            
            # ä½¿ç”¨è¿ç»­å‡½æ•°åŠ¨æ€è®¡ç®—æœ€å°ç¼©æ”¾ (0.05-1.0)
            # å†…å®¹è¶Šå¤§ï¼Œæœ€å°ç¼©æ”¾è¶Šå°
            min_scale = 1.0 * math.exp(-content_size_ratio * 1.2)
            min_scale = max(0.05, min(1.0, min_scale))
            
            # ä½¿ç”¨è¿ç»­å‡½æ•°åŠ¨æ€è®¡ç®—æœ€å¤§ç¼©æ”¾ (0.5-2.5)
            # å†…å®¹è¶Šå°ï¼Œå…è®¸çš„æœ€å¤§ç¼©æ”¾è¶Šå¤§
            max_scale = 0.5 + 2.0 * math.exp(-content_size_ratio * 0.8)
            max_scale = max(0.5, min(2.5, max_scale))
            
            # è®¡ç®—ä¸¤ä¸ªæ–¹å‘çš„ç¼©æ”¾æ¯”ä¾‹
            scale_x = (view_width * margin_factor) / scene_width
            scale_y = (view_height * margin_factor) / scene_height
            
            # é€‰æ‹©è¾ƒå°çš„ç¼©æ”¾æ¯”ä¾‹ä»¥ç¡®ä¿å†…å®¹å®Œå…¨å¯è§
            adaptive_scale = min(scale_x, scale_y)
            
            # åº”ç”¨ç¼©æ”¾èŒƒå›´é™åˆ¶
            adaptive_scale = max(min_scale, min(max_scale, adaptive_scale))
            
            print(f"ğŸ”§ [å…¨æ™¯å›¾] åŠ¨æ€è‡ªé€‚åº”ç¼©æ”¾è®¡ç®—:")
            print(f"  ğŸ“ è§†å›¾å°ºå¯¸: {view_width}x{view_height}")
            print(f"  ğŸ“¦ åœºæ™¯å°ºå¯¸: {scene_width:.1f}x{scene_height:.1f}")
            print(f"  ğŸ“Š å°ºå¯¸æ¯”ä¾‹: {content_size_ratio:.2f} (å®½:{width_ratio:.2f}, é«˜:{height_ratio:.2f})")
            print(f"  ğŸ¯ åŠ¨æ€å‚æ•°: è¾¹è·={margin_factor:.2f}, èŒƒå›´=[{min_scale:.2f}, {max_scale:.2f}]")
            print(f"  ğŸ“ è®¡ç®—ç¼©æ”¾: X={scale_x:.3f}, Y={scale_y:.3f}")
            print(f"  âœ… æœ€ç»ˆç¼©æ”¾: {adaptive_scale:.3f}")
            
            return adaptive_scale
            
        except Exception as e:
            print(f"âš ï¸ [å…¨æ™¯å›¾] åŠ¨æ€è‡ªé€‚åº”ç¼©æ”¾è®¡ç®—å¤±è´¥: {e}")
            # å‘ç”Ÿé”™è¯¯æ—¶è¿”å›é»˜è®¤ç¼©æ”¾
            return 0.25
    
    def _calculate_panorama_geometry(self):
        """è®¡ç®—å…¨æ™¯å›¾çš„å‡ ä½•ä¿¡æ¯"""
        if not self.hole_collection:
            return
        
        try:
            # ç›´æ¥ä½¿ç”¨æ•°æ®çš„å‡ ä½•ä¸­å¿ƒä½œä¸ºæ‰‡å½¢ä¸­å¿ƒç‚¹
            # è¿™æ ·å¯ä»¥ç¡®ä¿æ‰‡å½¢ä¸å­”ä½æ•°æ®å®Œç¾å¯¹é½
            bounds = self.hole_collection.get_bounds()
            original_center_x = (bounds[0] + bounds[2]) / 2
            original_center_y = (bounds[1] + bounds[3]) / 2
            
            # ä½¿ç”¨çœŸæ­£çš„æ•°æ®å‡ ä½•ä¸­å¿ƒï¼Œä¸åšä»»ä½•åç§»
            data_center_x = original_center_x
            data_center_y = original_center_y
            self.center_point = QPointF(data_center_x, data_center_y)
            
            print(f"ğŸ¯ [å…¨æ™¯å›¾] ä½¿ç”¨æ•°æ®å‡ ä½•ä¸­å¿ƒä½œä¸ºæ‰‡å½¢ä¸­å¿ƒ: ({self.center_point.x():.1f}, {self.center_point.y():.1f})")
            print(f"ğŸ“Š [å…¨æ™¯å›¾] æ•°æ®è¾¹ç•Œ: X=[{bounds[0]:.1f}, {bounds[2]:.1f}], Y=[{bounds[1]:.1f}, {bounds[3]:.1f}]")
            
            # è®¡ç®—åŠå¾„ï¼ˆä»ä¸­å¿ƒåˆ°æœ€è¿œå­”ä½çš„è·ç¦»ï¼‰
            max_distance = 0
            for hole in self.hole_collection.holes.values():
                dx = hole.center_x - data_center_x
                dy = hole.center_y - data_center_y
                distance = math.sqrt(dx * dx + dy * dy)
                max_distance = max(max_distance, distance)
            
            # æ·»åŠ ä¸€äº›è¾¹è·
            self.panorama_radius = max_distance * 0.8  # ä»0.9æ”¹ä¸º0.8ï¼Œè¿›ä¸€æ­¥ç¼©å°æ‰‡å½¢
            
            print(f"ğŸ“ [å…¨æ™¯å›¾] è®¡ç®—åŠå¾„: {self.panorama_radius:.1f} (æœ€è¿œè·ç¦»: {max_distance:.1f})")
            
            # è·å–è§†å›¾ä¿¡æ¯ç”¨äºè°ƒè¯•
            view_rect = self.panorama_view.viewport().rect()
            print(f"ğŸ“º [å…¨æ™¯å›¾] è§†å›¾å°ºå¯¸: {view_rect.width()}x{view_rect.height()}")
            
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] å‡ ä½•è®¡ç®—å¤±è´¥: {e}")
            # å¤‡ç”¨æ–¹æ¡ˆ
            if self.hole_collection:
                bounds = self.hole_collection.get_bounds()
                self.center_point = QPointF((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)
                self.panorama_radius = 100
            else:
                self.center_point = QPointF(0, 0)
                self.panorama_radius = 100
    
    def _create_sector_highlights(self):
        """åˆ›å»ºæ‰‡å½¢åŒºåŸŸé«˜äº®æ˜¾ç¤º"""
        if not self.center_point:
            print("âš ï¸ [å…¨æ™¯å›¾] æ— æ³•åˆ›å»ºæ‰‡å½¢é«˜äº®ï¼šä¸­å¿ƒç‚¹ä¿¡æ¯ä¸å®Œæ•´")
            return
        
        try:
            scene = self.panorama_view.scene
            if not scene:
                print("âš ï¸ [å…¨æ™¯å›¾] æ— æ³•åˆ›å»ºæ‰‡å½¢é«˜äº®ï¼šåœºæ™¯ä¸å­˜åœ¨")
                return
            
            print(f"ğŸ¯ [å…¨æ™¯å›¾] ä½¿ç”¨æ•°æ®ä¸­å¿ƒä½œä¸ºæ‰‡å½¢ä¸­å¿ƒ: ({self.center_point.x():.1f}, {self.center_point.y():.1f})")
            
            # å®‰å…¨æ¸…é™¤ç°æœ‰çš„é«˜äº®é¡¹
            for highlight in list(self.sector_highlights.values()):
                try:
                    if highlight.scene():
                        scene.removeItem(highlight)
                except RuntimeError:
                    pass  # å¯¹è±¡å·²è¢«åˆ é™¤ï¼Œå¿½ç•¥é”™è¯¯
            self.sector_highlights.clear()
            
            # ä½¿ç”¨ä¹‹å‰è®¡ç®—çš„æ•°æ®åŠå¾„
            display_radius = self.panorama_radius
            
            # è®¡ç®—çœŸæ­£çš„æ•°æ®ä¸­å¿ƒç‚¹ç”¨äºæ‰‡å½¢é«˜äº®ï¼ˆä¸åç§»ï¼‰
            bounds = self.hole_collection.get_bounds()
            true_center_x = (bounds[0] + bounds[2]) / 2
            true_center_y = (bounds[1] + bounds[3]) / 2
            true_center_point = QPointF(true_center_x, true_center_y)
            
            print(f"ğŸ¯ [æ‰‡å½¢é«˜äº®] ä½¿ç”¨çœŸæ­£çš„æ•°æ®ä¸­å¿ƒ: ({true_center_point.x():.1f}, {true_center_point.y():.1f})")
            print(f"ğŸ¯ [æ‰‡å½¢é«˜äº®] åç§»åçš„æ˜¾ç¤ºä¸­å¿ƒ: ({self.center_point.x():.1f}, {self.center_point.y():.1f})")
            
            # ä¸ºæ¯ä¸ªæ‰‡å½¢åˆ›å»ºé«˜äº®é¡¹ï¼Œä½¿ç”¨çœŸæ­£çš„æ•°æ®ä¸­å¿ƒ
            for sector in SectorQuadrant:
                highlight = SectorHighlightItem(
                    sector=sector,
                    center=true_center_point,  # ä½¿ç”¨çœŸæ­£çš„ä¸­å¿ƒç‚¹
                    radius=display_radius,
                    sector_bounds=None  # ä¸ä½¿ç”¨è¾¹ç•Œæ¡†æ¨¡å¼
                )
                
                # ä½¿ç”¨æ‰‡å½¢æ¨¡å¼
                highlight.set_highlight_mode("sector")
                
                # æ·»åŠ åˆ°åœºæ™¯
                scene.addItem(highlight)
                self.sector_highlights[sector] = highlight
                
                print(f"ğŸ¨ [å…¨æ™¯å›¾] åˆ›å»ºæ‰‡å½¢é«˜äº®: {sector.value}, ä¸­å¿ƒ=({true_center_point.x():.1f}, {true_center_point.y():.1f}), åŠå¾„={display_radius:.1f}")
            
            # åˆ›å»ºæ‰‡å½¢åˆ†éš”çº¿ï¼Œä½¿æ‰‡å½¢è¾¹ç•Œæ›´æ¸…æ™°
            self._create_sector_dividers()
            
            print(f"âœ… [å…¨æ™¯å›¾] æ‰‡å½¢é«˜äº®åˆ›å»ºå®Œæˆï¼Œå…± {len(self.sector_highlights)} ä¸ªæ‰‡å½¢")
            
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ‰‡å½¢é«˜äº®åˆ›å»ºå¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
    
    def _create_sector_dividers(self):
        """åˆ›å»ºæ‰‡å½¢åˆ†éš”çº¿ï¼Œä½¿æ‰‡å½¢è¾¹ç•Œæ›´æ¸…æ™°"""
        try:
            scene = self.panorama_view.scene
            if not scene or not self.center_point:
                return
            
            # åˆ›å»ºåå­—åˆ†éš”çº¿ - è¿›ä¸€æ­¥å¢å¼ºå¯è§æ€§
            pen = QPen(QColor(50, 50, 50), 3, Qt.SolidLine)
            
            # æ°´å¹³çº¿ï¼ˆåˆ†éš”ä¸Šä¸‹ï¼‰
            h_line = scene.addLine(
                self.center_point.x() - self.panorama_radius,
                self.center_point.y(),
                self.center_point.x() + self.panorama_radius,
                self.center_point.y(),
                pen
            )
            h_line.setZValue(15)  # åœ¨é«˜äº®å±‚ä¹‹ä¸Š
            h_line.setAcceptedMouseButtons(Qt.NoButton)
            
            # å‚ç›´çº¿ï¼ˆåˆ†éš”å·¦å³ï¼‰
            v_line = scene.addLine(
                self.center_point.x(),
                self.center_point.y() - self.panorama_radius,
                self.center_point.x(),
                self.center_point.y() + self.panorama_radius,
                pen
            )
            v_line.setZValue(15)  # åœ¨é«˜äº®å±‚ä¹‹ä¸Š
            v_line.setAcceptedMouseButtons(Qt.NoButton)
            
            # åˆ›å»ºä¸­å¿ƒç‚¹æ ‡è®° - å¢å¼ºå¯è§æ€§
            center_pen = QPen(QColor(255, 0, 0, 180), 3)
            center_brush = QBrush(QColor(255, 0, 0, 120))
            center_mark = scene.addEllipse(
                self.center_point.x() - 4,
                self.center_point.y() - 4,
                8,
                8,
                center_pen,
                center_brush
            )
            center_mark.setZValue(20)  # æœ€ä¸Šå±‚
            center_mark.setAcceptedMouseButtons(Qt.NoButton)
            
            print(f"âœ… [å…¨æ™¯å›¾] æ‰‡å½¢åˆ†éš”çº¿åˆ›å»ºå®Œæˆ")
            
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ‰‡å½¢åˆ†éš”çº¿åˆ›å»ºå¤±è´¥: {e}")
    
    
    def highlight_sector(self, sector: SectorQuadrant):
        """é«˜äº®æ˜¾ç¤ºæŒ‡å®šçš„æ‰‡å½¢åŒºåŸŸ"""
        try:
            # æ¸…é™¤æ‰€æœ‰é«˜äº®
            for s, highlight in self.sector_highlights.items():
                highlight.hide_highlight()
            
            # è°ƒè¯•ä¿¡æ¯ï¼ˆç®€åŒ–ï¼‰
            # print(f"ğŸ” [å…¨æ™¯å›¾] å½“å‰é«˜äº®å­—å…¸åŒ…å«: {list(self.sector_highlights.keys())}")
            # print(f"ğŸ” [å…¨æ™¯å›¾] è¦é«˜äº®çš„æ‰‡å½¢: {sector} (ç±»å‹: {type(sector)})")
            
            # é«˜äº®æŒ‡å®šæ‰‡å½¢
            if sector in self.sector_highlights:
                self.sector_highlights[sector].show_highlight()
                self.current_highlighted_sector = sector
                print(f"ğŸ¯ [å…¨æ™¯å›¾] é«˜äº®æ‰‡å½¢: {sector.value}")
            else:
                print(f"âš ï¸ [å…¨æ™¯å›¾] æ‰‡å½¢ {sector.value} çš„é«˜äº®é¡¹ä¸å­˜åœ¨")
                # å°è¯•é‡æ–°åˆ›å»ºé«˜äº®é¡¹
                if hasattr(self, 'center_point') and self.center_point and hasattr(self, 'panorama_radius'):
                    print(f"ğŸ”§ [å…¨æ™¯å›¾] å°è¯•é‡æ–°åˆ›å»ºæ‰‡å½¢ {sector.value} çš„é«˜äº®é¡¹")
                    
                    # è®¡ç®—çœŸæ­£çš„æ•°æ®ä¸­å¿ƒç‚¹ç”¨äºæ‰‡å½¢é«˜äº®ï¼ˆä¸åç§»ï¼‰
                    bounds = self.hole_collection.get_bounds()
                    true_center_x = (bounds[0] + bounds[2]) / 2
                    true_center_y = (bounds[1] + bounds[3]) / 2
                    true_center_point = QPointF(true_center_x, true_center_y)
                    
                    highlight = SectorHighlightItem(
                        sector=sector,
                        center=true_center_point,  # ä½¿ç”¨çœŸæ­£çš„ä¸­å¿ƒç‚¹
                        radius=self.panorama_radius,
                        sector_bounds=None
                    )
                    highlight.set_highlight_mode("sector")
                    if hasattr(self, 'panorama_view') and self.panorama_view.scene():
                        self.panorama_view.scene().addItem(highlight)
                        self.sector_highlights[sector] = highlight
                        highlight.show_highlight()
                        self.current_highlighted_sector = sector
                        print(f"âœ… [å…¨æ™¯å›¾] é‡æ–°åˆ›å»ºå¹¶é«˜äº®æ‰‡å½¢: {sector.value}")
                    else:
                        print(f"âŒ [å…¨æ™¯å›¾] æ— æ³•é‡æ–°åˆ›å»ºï¼Œåœºæ™¯ä¸å­˜åœ¨")
                
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ‰‡å½¢é«˜äº®å¤±è´¥: {e}")
    
    def clear_highlight(self):
        """æ¸…é™¤æ‰€æœ‰æ‰‡å½¢é«˜äº®"""
        try:
            # æ¸…é™¤æ‰€æœ‰é«˜äº®
            for highlight in self.sector_highlights.values():
                highlight.hide_highlight()
            self.current_highlighted_sector = None
            print("ğŸ§¹ [å…¨æ™¯å›¾] å·²æ¸…é™¤æ‰€æœ‰æ‰‡å½¢é«˜äº®")
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ¸…é™¤é«˜äº®å¤±è´¥: {e}")
    
    def set_highlight_mode(self, mode: str):
        """è®¾ç½®æ‰€æœ‰æ‰‡å½¢çš„é«˜äº®æ¨¡å¼"""
        for highlight_item in self.sector_highlights.values():
            highlight_item.set_highlight_mode(mode)
    
    def eventFilter(self, obj, event):
        """äº‹ä»¶è¿‡æ»¤å™¨ï¼Œå¤„ç†å…¨æ™¯è§†å›¾çš„é¼ æ ‡äº‹ä»¶"""
        if obj == self.panorama_view.viewport() and event.type() == QEvent.MouseButtonPress:
            if event.button() == Qt.LeftButton:
                # å°†è§†å£åæ ‡è½¬æ¢ä¸ºåœºæ™¯åæ ‡
                scene_pos = self.panorama_view.mapToScene(event.pos())
                
                print(f"ğŸ–±ï¸ [å…¨æ™¯å›¾] é¼ æ ‡ç‚¹å‡»: è§†å£åæ ‡={event.pos()}, åœºæ™¯åæ ‡=({scene_pos.x():.1f}, {scene_pos.y():.1f})")
                
                # æ£€æµ‹ç‚¹å‡»çš„æ‰‡å½¢
                clicked_sector = self._detect_clicked_sector(scene_pos)
                if clicked_sector:
                    print(f"ğŸ¯ [å…¨æ™¯å›¾] æ£€æµ‹åˆ°æ‰‡å½¢ç‚¹å‡»: {clicked_sector.value}")
                    self.sector_clicked.emit(clicked_sector)
                    # é«˜äº®è¢«ç‚¹å‡»çš„æ‰‡å½¢
                    self.highlight_sector(clicked_sector)
                    return True  # äº‹ä»¶å·²å¤„ç†
                else:
                    print(f"âŒ [å…¨æ™¯å›¾] æœªæ£€æµ‹åˆ°æ‰‡å½¢ç‚¹å‡»")
        
        return super().eventFilter(obj, event)
    
    def _detect_clicked_sector(self, scene_pos: QPointF) -> Optional[SectorQuadrant]:
        """æ£€æµ‹ç‚¹å‡»ä½ç½®å±äºå“ªä¸ªæ‰‡å½¢åŒºåŸŸ"""
        if not self.center_point:
            print(f"âš ï¸ [å…¨æ™¯å›¾] ä¸­å¿ƒç‚¹æœªè®¾ç½®")
            return None
        
        if not self.hole_collection:
            print(f"âš ï¸ [å…¨æ™¯å›¾] å­”ä½é›†åˆæœªè®¾ç½®")
            return None
        
        try:
            # è®¡ç®—ç‚¹å‡»ä½ç½®ç›¸å¯¹äºä¸­å¿ƒçš„å‘é‡
            dx = scene_pos.x() - self.center_point.x()
            dy = scene_pos.y() - self.center_point.y()
            
            # è®¡ç®—è·ç¦»ï¼Œåˆ¤æ–­æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
            distance = math.sqrt(dx * dx + dy * dy)
            print(f"ğŸ“ [å…¨æ™¯å›¾] ç‚¹å‡»è·ç¦»ä¸­å¿ƒ: {distance:.1f}, åŠå¾„: {self.panorama_radius:.1f}")
            
            # æ”¾å®½è·ç¦»æ£€æŸ¥ï¼Œåªè¦ä¸æ˜¯å¤ªè¿œçš„ç‚¹å‡»éƒ½è®¤ä¸ºæœ‰æ•ˆ
            max_valid_distance = self.panorama_radius * 1.5 if self.panorama_radius > 0 else 1000
            if distance > max_valid_distance:
                print(f"âŒ [å…¨æ™¯å›¾] ç‚¹å‡»è·ç¦»è¿‡è¿œ: {distance:.1f} > {max_valid_distance:.1f}")
                return None
            
            # è®¡ç®—è§’åº¦
            angle_rad = math.atan2(dy, dx)
            angle_deg = math.degrees(angle_rad)
            
            # è½¬æ¢ä¸º0-360åº¦èŒƒå›´
            if angle_deg < 0:
                angle_deg += 360
            
            print(f"ğŸ“ [å…¨æ™¯å›¾] ç‚¹å‡»è§’åº¦: {angle_deg:.1f}Â°, ä¸­å¿ƒç‚¹: ({self.center_point.x():.1f}, {self.center_point.y():.1f})")
            
            # ä½¿ç”¨ä¸ä¸»è§†å›¾SectorManagerç›¸åŒçš„æ•°å­¦åæ ‡ç³»ï¼ˆä¸è½¬æ¢ï¼‰
            # ç›´æ¥ä½¿ç”¨æ•°å­¦è§’åº¦ç³»ç»Ÿï¼Œä¸ä¸»è§†å›¾ä¿æŒä¸€è‡´
            
            # æ•°å­¦åæ ‡ç³»ä¸­çš„æ‰‡å½¢å®šä¹‰ï¼ˆä¸SectorManagerä¿æŒä¸€è‡´ï¼‰ï¼š
            # åŒºåŸŸ1ï¼š0Â°-90Â°ï¼ˆå³ä¸Šï¼‰
            # åŒºåŸŸ2ï¼š90Â°-180Â°ï¼ˆå·¦ä¸Šï¼‰
            # åŒºåŸŸ3ï¼š180Â°-270Â°ï¼ˆå·¦ä¸‹ï¼‰
            # åŒºåŸŸ4ï¼š270Â°-360Â°ï¼ˆå³ä¸‹ï¼‰
            if 0 <= angle_deg < 90:
                return SectorQuadrant.SECTOR_1  # å³ä¸Š
            elif 90 <= angle_deg < 180:
                return SectorQuadrant.SECTOR_2  # å·¦ä¸Š
            elif 180 <= angle_deg < 270:
                return SectorQuadrant.SECTOR_3  # å·¦ä¸‹
            else:  # 270 <= angle_deg < 360
                return SectorQuadrant.SECTOR_4  # å³ä¸‹
                
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ‰‡å½¢æ£€æµ‹å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def update_hole_status(self, hole_id: str, status):
        """æ›´æ–°å­”ä½çŠ¶æ€ï¼ˆæ™ºèƒ½æ‰¹é‡/å®æ—¶æ›´æ–°ç‰ˆæœ¬ï¼‰"""
        print(f"ğŸ“¦ [å…¨æ™¯å›¾] æ¥æ”¶åˆ°çŠ¶æ€æ›´æ–°: {hole_id} -> {status.value if hasattr(status, 'value') else status}")
        
        # æ£€æŸ¥æ˜¯å¦åœ¨æ¨¡æ‹ŸæœŸé—´
        is_simulation_running = self._check_simulation_status()
        
        if is_simulation_running:
            # æ¨¡æ‹ŸæœŸé—´ï¼šç›´æ¥å®æ—¶æ›´æ–°
            print(f"ğŸ”¥ [å…¨æ™¯å›¾] æ¨¡æ‹ŸæœŸé—´ï¼Œä½¿ç”¨å®æ—¶æ›´æ–°")
            self._apply_single_update(hole_id, status)
        else:
            # æ­£å¸¸æœŸé—´ï¼šä½¿ç”¨æ‰¹é‡æ›´æ–°
            print(f"ğŸ“¦ [å…¨æ™¯å›¾] æ­£å¸¸æœŸé—´ï¼Œä½¿ç”¨æ‰¹é‡æ›´æ–°")
            
            # å°†çŠ¶æ€æ›´æ–°åŠ å…¥ç¼“å­˜
            self.pending_status_updates[hole_id] = status
            
            # é‡å¯æ‰¹é‡æ›´æ–°å®šæ—¶å™¨
            if self.batch_update_timer.isActive():
                print(f"â¹ï¸ [å…¨æ™¯å›¾] åœæ­¢ç°æœ‰å®šæ—¶å™¨")
                self.batch_update_timer.stop()
            
            print(f"â° [å…¨æ™¯å›¾] å¯åŠ¨æ‰¹é‡æ›´æ–°å®šæ—¶å™¨: {self.batch_update_interval}msï¼Œå½“å‰é˜Ÿåˆ—: {len(self.pending_status_updates)}ä¸ª")
            self.batch_update_timer.start(self.batch_update_interval)
            
            # éªŒè¯å®šæ—¶å™¨æ˜¯å¦çœŸçš„å¯åŠ¨äº†
            if self.batch_update_timer.isActive():
                print(f"âœ… [å…¨æ™¯å›¾] å®šæ—¶å™¨å·²æ¿€æ´»ï¼Œ{self.batch_update_timer.remainingTime()}ms åæ‰§è¡Œ")
            else:
                print(f"âŒ [å…¨æ™¯å›¾] å®šæ—¶å™¨å¯åŠ¨å¤±è´¥!")
            
            print(f"ğŸ”„ [å…¨æ™¯å›¾] ç¼“å­˜ä¸­ç°æœ‰ {len(self.pending_status_updates)} ä¸ªå¾…æ›´æ–°")
    
    def _check_simulation_status(self) -> bool:
        """æ£€æŸ¥å½“å‰æ˜¯å¦åœ¨æ¨¡æ‹ŸæœŸé—´"""
        try:
            # é€šè¿‡parentæ‰¾åˆ°ä¸»çª—å£æ£€æŸ¥æ¨¡æ‹ŸçŠ¶æ€
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'simulation_running'):
                main_window = main_window.parent()
            
            if main_window:
                simulation_v1 = getattr(main_window, 'simulation_running', False)
                simulation_v2 = getattr(main_window, 'simulation_running_v2', False)
                is_running = simulation_v1 or simulation_v2
                if is_running:
                    print(f"ğŸ¯ [å…¨æ™¯å›¾] æ£€æµ‹åˆ°æ¨¡æ‹Ÿè¿è¡Œä¸­: V1={simulation_v1}, V2={simulation_v2}")
                return is_running
            else:
                print(f"âš ï¸ [å…¨æ™¯å›¾] æ— æ³•æ‰¾åˆ°ä¸»çª—å£ï¼Œå‡è®¾éæ¨¡æ‹ŸæœŸé—´")
                return False
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ¨¡æ‹ŸçŠ¶æ€æ£€æŸ¥å¤±è´¥: {e}")
            return False
    
    def _apply_single_update(self, hole_id: str, status):
        """ç«‹å³åº”ç”¨å•ä¸ªå­”ä½çŠ¶æ€æ›´æ–°"""
        print(f"âš¡ [å…¨æ™¯å›¾] ç«‹å³æ›´æ–°å­”ä½: {hole_id} -> {status.value if hasattr(status, 'value') else status}")
        
        try:
            # è·å–çŠ¶æ€é¢œè‰²
            from aidcis2.models.hole_data import HoleStatus
            from PySide6.QtGui import QColor, QBrush, QPen
            
            color_map = {
                HoleStatus.PENDING: QColor(200, 200, 200),      # ç°è‰²
                HoleStatus.QUALIFIED: QColor(76, 175, 80),      # ç»¿è‰²
                HoleStatus.DEFECTIVE: QColor(244, 67, 54),      # çº¢è‰²
                HoleStatus.PROCESSING: QColor(33, 150, 243),    # è“è‰²
                HoleStatus.BLIND: QColor(255, 193, 7),          # é»„è‰²
                HoleStatus.TIE_ROD: QColor(156, 39, 176)        # ç´«è‰²
            }
            
            # è½¬æ¢çŠ¶æ€
            if isinstance(status, str):
                try:
                    status = HoleStatus(status)
                except ValueError:
                    status = HoleStatus.PENDING
            
            color = color_map.get(status, QColor(200, 200, 200))
            
            # ç«‹å³æ›´æ–°å›¾å½¢é¡¹
            if hasattr(self.panorama_view, 'hole_items') and hole_id in self.panorama_view.hole_items:
                hole_item = self.panorama_view.hole_items[hole_id]
                hole_item.setBrush(QBrush(color))
                hole_item.setPen(QPen(color.darker(120), 1))
                
                # å¼ºåˆ¶ç«‹å³é‡ç»˜
                hole_item.update()
                self.panorama_view.update()
                print(f"âœ… [å…¨æ™¯å›¾] ç«‹å³æ›´æ–°å®Œæˆ: {hole_id}")
            else:
                print(f"âŒ [å…¨æ™¯å›¾] æœªæ‰¾åˆ°å­”ä½å›¾å½¢é¡¹: {hole_id}")
                
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] ç«‹å³æ›´æ–°å¤±è´¥: {e}")
    
    def _apply_batch_updates(self):
        """åº”ç”¨æ‰¹é‡çŠ¶æ€æ›´æ–°"""
        print(f"ğŸš€ [å…¨æ™¯å›¾] *** æ‰¹é‡æ›´æ–°å®šæ—¶å™¨è¢«è§¦å‘! ***")
        
        if not self.pending_status_updates:
            print(f"âš ï¸ [å…¨æ™¯å›¾] ç¼“å­˜ä¸ºç©ºï¼Œè·³è¿‡æ›´æ–°")
            return
        
        update_count = len(self.pending_status_updates)
        print(f"ğŸ”„ [å…¨æ™¯å›¾] å¼€å§‹æ‰¹é‡æ›´æ–° {update_count} ä¸ªå­”ä½çŠ¶æ€")
        
        try:
            # è·å–å…¨æ™¯è§†å›¾ä¸­çš„å­”ä½å›¾å½¢é¡¹
            if hasattr(self.panorama_view, 'hole_items'):
                hole_items_count = len(self.panorama_view.hole_items) if self.panorama_view.hole_items else 0
                print(f"ğŸ” [å…¨æ™¯å›¾] å…¨æ™¯è§†å›¾ä¸­æœ‰ {hole_items_count} ä¸ªå­”ä½å›¾å½¢é¡¹")
                
                if hole_items_count == 0:
                    print(f"âŒ [å…¨æ™¯å›¾] hole_items ä¸ºç©º! æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®åŠ è½½åˆ°å…¨æ™¯è§†å›¾")
                    # æ£€æŸ¥å…¨æ™¯è§†å›¾çš„å…¶ä»–å±æ€§
                    if hasattr(self.panorama_view, 'scene') and self.panorama_view.scene:
                        scene_items = self.panorama_view.scene.items()
                        print(f"ğŸ” [å…¨æ™¯å›¾] åœºæ™¯ä¸­æœ‰ {len(scene_items)} ä¸ªå›¾å½¢é¡¹")
                    else:
                        print(f"âŒ [å…¨æ™¯å›¾] å…¨æ™¯è§†å›¾æ²¡æœ‰åœºæ™¯æˆ–åœºæ™¯ä¸ºç©º")
                    
                if self.panorama_view.hole_items:
                    updated_count = 0
                    print(f"ğŸ” [å…¨æ™¯å›¾] æ­£åœ¨æ£€æŸ¥ {len(self.pending_status_updates)} ä¸ªå¾…æ›´æ–°å­”ä½")
                
                # çŠ¶æ€é¢œè‰²æ˜ å°„
                from aidcis2.models.hole_data import HoleStatus
                from PySide6.QtGui import QColor, QBrush, QPen
                
                status_colors = {
                    HoleStatus.PENDING: QColor("#CCCCCC"),       # ç°è‰²
                    HoleStatus.QUALIFIED: QColor("#4CAF50"),     # ç»¿è‰²
                    HoleStatus.DEFECTIVE: QColor("#F44336"),     # çº¢è‰²
                    HoleStatus.PROCESSING: QColor("#2196F3"),    # è“è‰²
                    HoleStatus.BLIND: QColor("#FF9800"),         # æ©™è‰²
                    HoleStatus.TIE_ROD: QColor("#9C27B0"),       # ç´«è‰²
                }
                
                # æ‰¹é‡æ›´æ–°æ‰€æœ‰ç¼“å­˜çš„çŠ¶æ€å˜åŒ–
                for hole_id, status in self.pending_status_updates.items():
                    print(f"ğŸ” [å…¨æ™¯å›¾] æ£€æŸ¥å­”ä½ {hole_id}, çŠ¶æ€: {status.value if hasattr(status, 'value') else status}")
                    
                    if hole_id in self.panorama_view.hole_items:
                        hole_item = self.panorama_view.hole_items[hole_id]
                        print(f"âœ… [å…¨æ™¯å›¾] æ‰¾åˆ°å­”ä½å›¾å½¢é¡¹: {hole_id}, ç±»å‹: {type(hole_item)}")
                        
                        # ä¼˜å…ˆä½¿ç”¨update_statusæ–¹æ³•ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ç›´æ¥è®¾ç½®é¢œè‰²
                        if hasattr(hole_item, 'update_status'):
                            hole_item.update_status(status)
                            hole_item.update()
                            updated_count += 1
                            print(f"âœ… [å…¨æ™¯å›¾] å­”ä½ {hole_id} ä½¿ç”¨update_statusæ›´æ–°æˆåŠŸ")
                        elif status in status_colors:
                            color = status_colors[status]
                            print(f"ğŸ¨ [å…¨æ™¯å›¾] è®¾ç½®é¢œè‰²: {color.name()}")
                            
                            if hasattr(hole_item, 'setBrush') and hasattr(hole_item, 'setPen'):
                                hole_item.setBrush(QBrush(color))
                                hole_item.setPen(QPen(color.darker(120), 1.0))
                                hole_item.update()
                                updated_count += 1
                                print(f"âœ… [å…¨æ™¯å›¾] å­”ä½ {hole_id} é¢œè‰²æ›´æ–°æˆåŠŸ")
                            else:
                                print(f"âŒ [å…¨æ™¯å›¾] å­”ä½å›¾å½¢é¡¹ç¼ºå°‘ setBrush/setPen æ–¹æ³•")
                        else:
                            print(f"âŒ [å…¨æ™¯å›¾] æœªçŸ¥çŠ¶æ€: {status}")
                    else:
                        print(f"âŒ [å…¨æ™¯å›¾] å­”ä½ {hole_id} ä¸åœ¨ hole_items ä¸­")
                        if self.panorama_view.hole_items:
                            available_holes = list(self.panorama_view.hole_items.keys())[:5]  # æ˜¾ç¤ºå‰5ä¸ªå¯ç”¨å­”ä½
                            print(f"ğŸ” [å…¨æ™¯å›¾] å¯ç”¨å­”ä½ç¤ºä¾‹: {available_holes}")
                
                # å¼ºåˆ¶åˆ·æ–°è§†å›¾ï¼ˆä¸€æ¬¡æ€§ï¼‰
                self.panorama_view.scene.update()
                self.panorama_view.viewport().update()
                
                # å¦‚æœæœ‰æ›´æ–°ï¼Œå¼ºåˆ¶é‡ç»˜ä»¥ç¡®ä¿æ˜¾ç¤º
                if updated_count > 0:
                    from PySide6.QtCore import QTimer
                    QTimer.singleShot(10, lambda: self.panorama_view.viewport().repaint())
                
                print(f"âœ… [å…¨æ™¯å›¾] æ‰¹é‡æ›´æ–°å®Œæˆ: {updated_count}/{update_count} ä¸ªå­”ä½")
            else:
                print("âŒ [å…¨æ™¯å›¾] panorama_view æ²¡æœ‰ hole_items å±æ€§!")
                print(f"ğŸ” [å…¨æ™¯å›¾] panorama_view ç±»å‹: {type(self.panorama_view)}")
                if hasattr(self.panorama_view, '__dict__'):
                    attrs = list(self.panorama_view.__dict__.keys())[:10]  # æ˜¾ç¤ºå‰10ä¸ªå±æ€§
                    print(f"ğŸ” [å…¨æ™¯å›¾] panorama_view å±æ€§: {attrs}")
            
        except Exception as e:
            print(f"âŒ [å…¨æ™¯å›¾] æ‰¹é‡æ›´æ–°å¤±è´¥: {e}")
        finally:
            # æ¸…ç©ºç¼“å­˜
            self.pending_status_updates.clear()
    
    def batch_update_hole_status(self, status_updates: Dict[str, any]):
        """ç›´æ¥æ‰¹é‡æ›´æ–°å¤šä¸ªå­”ä½çŠ¶æ€"""
        print(f"ğŸš€ [å…¨æ™¯å›¾] ç›´æ¥æ‰¹é‡æ›´æ–° {len(status_updates)} ä¸ªå­”ä½")
        
        # åˆå¹¶åˆ°å¾…æ›´æ–°ç¼“å­˜
        self.pending_status_updates.update(status_updates)
        
        # ç«‹å³åº”ç”¨æ›´æ–°
        self._apply_batch_updates()
    
    def set_batch_update_interval(self, interval_ms: int):
        """è®¾ç½®æ‰¹é‡æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰"""
        self.batch_update_interval = interval_ms
        print(f"âš™ï¸ [å…¨æ™¯å›¾] æ‰¹é‡æ›´æ–°é—´éš”è®¾ç½®ä¸º: {interval_ms}ms")
    
    def force_immediate_update(self):
        """å¼ºåˆ¶ç«‹å³åº”ç”¨æ‰€æœ‰å¾…æ›´æ–°çš„çŠ¶æ€å˜åŒ–"""
        if self.batch_update_timer.isActive():
            self.batch_update_timer.stop()
        if self.pending_status_updates:
            self._apply_batch_updates()
    
    def debug_update_coverage(self):
        """è°ƒè¯•æ–¹æ³•ï¼šæ£€æŸ¥æ›´æ–°è¦†ç›–èŒƒå›´"""
        if not hasattr(self.panorama_view, 'hole_items') or not self.panorama_view.hole_items:
            print("âŒ [è°ƒè¯•] æ²¡æœ‰hole_items")
            return
        
        # ç»Ÿè®¡å„åŒºåŸŸçš„å­”ä½å’Œæ›´æ–°æƒ…å†µ
        regions = {
            "å³ä¸Š": {"range": (0, 90), "holes": [], "updated": []},
            "å·¦ä¸Š": {"range": (90, 180), "holes": [], "updated": []},
            "å·¦ä¸‹": {"range": (180, 270), "holes": [], "updated": []},
            "å³ä¸‹": {"range": (270, 360), "holes": [], "updated": []},
        }
        
        for hole_id, item in self.panorama_view.hole_items.items():
            # è®¡ç®—å­”ä½è§’åº¦
            pos = item.pos()
            if self.center_point:
                dx = pos.x() - self.center_point.x()
                dy = pos.y() - self.center_point.y()
                import math
                angle = math.degrees(math.atan2(dy, dx))
                if angle < 0:
                    angle += 360
                
                # ç¡®å®šæ‰€å±åŒºåŸŸ
                for region_name, region_data in regions.items():
                    min_angle, max_angle = region_data["range"]
                    if min_angle <= angle < max_angle:
                        region_data["holes"].append(hole_id)
                        
                        # æ£€æŸ¥æ˜¯å¦è¢«æ›´æ–°è¿‡ï¼ˆé€šè¿‡é¢œè‰²åˆ¤æ–­ï¼‰
                        if hasattr(item, 'brush'):
                            color = item.brush().color().name()
                            if color != "#CCCCCC":  # éé»˜è®¤ç°è‰²
                                region_data["updated"].append(hole_id)
                        break
        
        # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        print("\nğŸ“Š [è°ƒè¯•] å…¨æ™¯å›¾æ›´æ–°è¦†ç›–èŒƒå›´:")
        for region_name, data in regions.items():
            total = len(data["holes"])
            updated = len(data["updated"])
            percentage = (updated / total * 100) if total > 0 else 0
            print(f"  {region_name}: {updated}/{total} ({percentage:.1f}%)")
            if updated < total and total > 0:
                not_updated = set(data["holes"]) - set(data["updated"])
                print(f"    æœªæ›´æ–°: {list(not_updated)[:5]}...")  # æ˜¾ç¤ºå‰5ä¸ª