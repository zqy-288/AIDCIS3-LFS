"""
[DEPRECATED] ä¸»çª—å£æ§åˆ¶å™¨ - å·²åºŸå¼ƒ
è´Ÿè´£åè°ƒMainWindowçš„æ‰€æœ‰ä¸šåŠ¡é€»è¾‘ï¼Œå®ç°UIä¸ä¸šåŠ¡çš„åˆ†ç¦»

âš ï¸ æ­¤æ–‡ä»¶å·²è¢«é‡æ„åçš„æ–°æ¶æ„æ›¿ä»£ï¼š
- é‡æ„æ§åˆ¶å™¨: /src/controllers/main_window_controller_refactored.py
- ç”¨ä¾‹å±‚: /src/application/use_cases/batch_detection_use_case.py
- äº‹ä»¶æ€»çº¿: /src/infrastructure/event_bus.py

æ–°æ¶æ„é‡‡ç”¨DDDè®¾è®¡ï¼Œå…·æœ‰æ›´å¥½çš„è§£è€¦æ€§å’Œå¯æµ‹è¯•æ€§ã€‚
è¯·ä½¿ç”¨æ–°çš„æ§åˆ¶å™¨å®ç°ï¼Œæœ¬æ–‡ä»¶ä»…ä¿ç•™ç”¨äºå‘åå…¼å®¹ã€‚
"""

import logging
from typing import Optional, Dict, Any, List
from pathlib import Path
from PySide6.QtCore import QObject, Signal, QTimer
from PySide6.QtWidgets import QMessageBox, QFileDialog

from src.services import get_business_service, get_graphics_service
from src.ui.factories import get_ui_factory


class MainWindowController(QObject):
    """
    ä¸»çª—å£æ§åˆ¶å™¨
    å¤„ç†æ‰€æœ‰ä¸šåŠ¡é€»è¾‘å’Œç»„ä»¶åè°ƒ
    """
    
    # ä¿¡å·å®šä¹‰
    status_updated = Signal(str, str)  # hole_id, status
    detection_started = Signal()
    detection_stopped = Signal()
    detection_progress = Signal(int, int)  # current, total
    file_loaded = Signal(str)  # file_path
    error_occurred = Signal(str)  # error_message
    
    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        
        # æœåŠ¡å±‚
        self.business_service = get_business_service()
        self.graphics_service = get_graphics_service()
        self.ui_factory = get_ui_factory()
        
        # æ‰¹æ¬¡ç®¡ç†å™¨ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰
        self._batch_manager = None
        self._detection_service = None
        
        # çŠ¶æ€ç®¡ç†
        self.current_file_path: Optional[str] = None
        self.current_product: Optional[str] = None
        self.current_product_id: Optional[int] = None
        self.hole_collection = None
        self.current_batch_id: Optional[str] = None
        
        # æ£€æµ‹çŠ¶æ€
        self.detection_running = False
        self.detection_paused = False
        self.detection_holes = []
        self.detection_index = 0
        
        # å®šæ—¶å™¨
        self.detection_timer = QTimer()
        self.detection_timer.timeout.connect(self._process_detection_step)
        
        # è›‡å½¢è·¯å¾„ç›¸å…³
        self.snake_path_coordinator = None
        self.snake_sorted_holes = []
        self.snake_simulation_index = 0
        self.simulation_timer = QTimer()
        self.simulation_timer.timeout.connect(self._process_simulation_step)
        self.is_simulation_running = False
        self.is_simulation_paused = False
    
    @property
    def batch_service(self):
        """å»¶è¿ŸåŠ è½½æ‰¹æ¬¡æœåŠ¡"""
        if self._batch_manager is None:
            from src.domain.services.batch_service import BatchService
            from src.infrastructure.repositories.batch_repository_impl import BatchRepositoryImpl
            repository = BatchRepositoryImpl()
            self._batch_manager = BatchService(repository)
        return self._batch_manager
    
    @property
    def detection_service(self):
        """å»¶è¿ŸåŠ è½½æ£€æµ‹æœåŠ¡"""
        if self._detection_service is None:
            from src.services.detection_service import DetectionService
            self._detection_service = DetectionService()
            self._detection_service.set_batch_service(self.batch_service)
        return self._detection_service
        
    def initialize(self):
        """åˆå§‹åŒ–æ§åˆ¶å™¨"""
        self.logger.info("Initializing MainWindow controller")
        
        # é¢„åŠ è½½å…³é”®ç»„ä»¶
        # æ³¨æ„ï¼šhistory_viewer å·²åœ¨ä¸»çª—å£ä¸­ç›´æ¥åˆ›å»ºï¼Œä¸éœ€è¦é¢„åŠ è½½
        self.ui_factory.preload_components(['realtime_chart'])
        
        # åˆå§‹åŒ–è›‡å½¢è·¯å¾„åè°ƒå™¨
        self.snake_path_coordinator = self.graphics_service.create_snake_path_coordinator()
        
        # è¿æ¥shared_data_managerçš„ä¿¡å·
        try:
            from src.core.shared_data_manager import SharedDataManager
            shared_data = SharedDataManager()
            shared_data.data_changed.connect(self._on_shared_data_changed)
            self.logger.info("Connected to SharedDataManager signals")
        except Exception as e:
            self.logger.warning(f"Could not connect to SharedDataManager: {e}")
        
    def load_dxf_file(self, file_path: Optional[str] = None) -> bool:
        """
        åŠ è½½DXFæ–‡ä»¶
        
        Args:
            file_path: æ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœä¸ºNoneåˆ™æ˜¾ç¤ºæ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†
            
        Returns:
            æ˜¯å¦åŠ è½½æˆåŠŸ
        """
        try:
            if not file_path:
                file_path, _ = QFileDialog.getOpenFileName(
                    None,
                    "é€‰æ‹©DXFæ–‡ä»¶",
                    "",
                    "DXF Files (*.dxf);;All Files (*)"
                )
                
            if not file_path:
                return False
                
            # è§£æDXFæ–‡ä»¶
            self.hole_collection = self.business_service.parse_dxf_file(file_path)
            
            if not self.hole_collection:
                self.error_occurred.emit("æ— æ³•è§£æDXFæ–‡ä»¶")
                return False
                
            # åº”ç”¨å­”ä½ç¼–å·
            self.hole_collection = self.business_service.apply_hole_numbering(
                self.hole_collection, 
                strategy="grid"
            )
            
            # è®¾ç½®åˆ°å…±äº«æ•°æ®ç®¡ç†å™¨
            self.business_service.set_hole_collection(self.hole_collection)
            
            # è°ƒè¯•ä¿¡æ¯
            print(f"[DEBUG Controller] hole_collection åŒ…å« {len(self.hole_collection.holes)} ä¸ªå­”ä½")
            test_collection = self.business_service.get_hole_collection()
            if test_collection:
                print(f"[DEBUG Controller] business_service è¿”å› {len(test_collection.holes)} ä¸ªå­”ä½")
            else:
                print("[DEBUG Controller] business_service.get_hole_collection() è¿”å› None")
            
            # æ›´æ–°çŠ¶æ€
            self.current_file_path = file_path
            self.file_loaded.emit(file_path)
            
            self.logger.info(f"Successfully loaded DXF file: {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error loading DXF file: {e}")
            self.error_occurred.emit(str(e))
            return False
    
    def _on_shared_data_changed(self, data_type: str, data: Any):
        """å¤„ç†å…±äº«æ•°æ®å˜åŒ–"""
        if data_type == "hole_collection" and data:
            self.logger.info(f"Received hole_collection from SharedDataManager: {len(data.holes)} holes")
            self.hole_collection = data
            # å‘å°„æ–‡ä»¶åŠ è½½ä¿¡å·ï¼Œé€šçŸ¥UIæ›´æ–°
            self.file_loaded.emit("CAP1000.dxf")
            
    def select_product(self, product_name: str) -> bool:
        """é€‰æ‹©äº§å“"""
        try:
            if self.business_service.select_product(product_name):
                self.current_product = product_name
                # è·å–äº§å“å®ä¾‹ä»¥ä¿å­˜ID
                if hasattr(self.business_service, 'current_product') and self.business_service.current_product:
                    self.current_product_id = self.business_service.current_product.id
                self.logger.info(f"Selected product: {product_name}")
                return True
            return False
        except Exception as e:
            self.logger.error(f"Error selecting product: {e}")
            self.error_occurred.emit(str(e))
            return False
    
    def check_resumable_batch(self, is_mock: bool = False) -> Optional[Dict]:
        """æ£€æŸ¥æ˜¯å¦æœ‰å¯æ¢å¤çš„æ‰¹æ¬¡"""
        if not self.current_product_id:
            return None
            
        batch = self.batch_service.get_resumable_batch(self.current_product_id, is_mock)
        if batch:
            return {
                'batch_id': batch.batch_id,
                'detection_number': batch.detection_number,
                'completed_holes': batch.completed_holes,
                'total_holes': batch.total_holes,
                'pause_time': batch.updated_at
            }
        return None
            
    def start_detection(self, is_mock: bool = False):
        """å¼€å§‹æ£€æµ‹"""
        if not self.hole_collection:
            self.error_occurred.emit("è¯·å…ˆåŠ è½½DXFæ–‡ä»¶")
            return
            
        if not self.current_product_id:
            self.error_occurred.emit("è¯·å…ˆé€‰æ‹©äº§å“")
            return
            
        # åˆ›å»ºæ–°æ‰¹æ¬¡
        try:
            # è°ƒè¯•ï¼šæ‰“å°äº§å“ä¿¡æ¯æ ¼å¼
            self.logger.info(f"ğŸ” è°ƒè¯•äº§å“ä¿¡æ¯: type={type(self.current_product)}, value={self.current_product}")
            
            # è·å–äº§å“åç§° - å¤„ç†ä¸åŒçš„äº§å“ä¿¡æ¯æ ¼å¼
            if hasattr(self.current_product, 'model_name'):
                # ProductModelå¯¹è±¡
                product_name = self.current_product.model_name
                self.logger.info(f"âœ… ä½¿ç”¨ProductModelå¯¹è±¡: {product_name}")
            elif isinstance(self.current_product, dict):
                # å­—å…¸æ ¼å¼
                product_name = self.current_product.get('model_name', 'Unknown')
                self.logger.info(f"âœ… ä½¿ç”¨å­—å…¸æ ¼å¼: {product_name}")
            elif isinstance(self.current_product, str):
                # å­—ç¬¦ä¸²æ ¼å¼
                product_name = self.current_product
                self.logger.info(f"âœ… ä½¿ç”¨å­—ç¬¦ä¸²æ ¼å¼: {product_name}")
            else:
                product_name = "Unknown"
                self.logger.warning(f"âš ï¸ æœªçŸ¥äº§å“æ ¼å¼ï¼Œä½¿ç”¨é»˜è®¤å€¼: {product_name}")
            batch = self.batch_service.create_batch(
                product_id=self.current_product_id,
                product_name=product_name,
                is_mock=is_mock
            )
            self.current_batch_id = batch.batch_id
            self.logger.info(f"Created batch: {batch.batch_id}")
        except Exception as e:
            self.error_occurred.emit(f"åˆ›å»ºæ‰¹æ¬¡å¤±è´¥: {str(e)}")
            return
            
        self.detection_running = True
        self.detection_paused = False
        self.detection_index = 0
        
        # è·å–æ‰€æœ‰å¾…æ£€æµ‹çš„å­”ä½
        self.detection_holes = list(self.hole_collection.holes.values())
        
        # ä½¿ç”¨æ£€æµ‹æœåŠ¡
        self.detection_service.start_detection(
            self.detection_holes,
            batch_id=self.current_batch_id,
            is_mock=is_mock
        )
        
        # å¼€å§‹æ£€æµ‹
        self.detection_started.emit()
        self.detection_timer.start(100)  # æ¯100mså¤„ç†ä¸€ä¸ªå­”ä½
    
    def continue_detection(self, batch_id: str):
        """ç»§ç»­æ£€æµ‹"""
        # åŠ è½½æ‰¹æ¬¡çŠ¶æ€
        detection_state = self.batch_service.resume_batch(batch_id)
        if not detection_state:
            self.error_occurred.emit("æ— æ³•æ¢å¤æ£€æµ‹çŠ¶æ€")
            return
            
        self.current_batch_id = batch_id
        
        # ä½¿ç”¨æ£€æµ‹æœåŠ¡æ¢å¤
        if self.detection_service.resume_detection(detection_state):
            self.detection_running = True
            self.detection_paused = False
            self.detection_started.emit()
        else:
            self.error_occurred.emit("æ¢å¤æ£€æµ‹å¤±è´¥")
        
    def pause_detection(self):
        """æš‚åœæ£€æµ‹"""
        self.detection_paused = True
        self.detection_timer.stop()
        
        # ä½¿ç”¨æ£€æµ‹æœåŠ¡æš‚åœ
        if self.detection_service.pause_detection():
            self.logger.info("Detection paused and state saved")
        
    def resume_detection(self):
        """æ¢å¤æ£€æµ‹ï¼ˆå·²åºŸå¼ƒï¼Œä½¿ç”¨continue_detectionï¼‰"""
        if self.detection_running and self.detection_paused:
            self.detection_paused = False
            self.detection_timer.start(100)
            
    def stop_detection(self):
        """åœæ­¢æ£€æµ‹ï¼ˆç»ˆæ­¢ï¼‰"""
        self.detection_running = False
        self.detection_paused = False
        self.detection_timer.stop()
        
        # ç»ˆæ­¢æ‰¹æ¬¡
        if self.current_batch_id:
            self.batch_service.terminate_batch(self.current_batch_id)
            
        self.detection_stopped.emit()
        
    def _process_detection_step(self):
        """å¤„ç†å•ä¸ªæ£€æµ‹æ­¥éª¤"""
        if not self.detection_running or self.detection_paused:
            return
            
        if self.detection_index >= len(self.detection_holes):
            # æ£€æµ‹å®Œæˆ
            self.stop_detection()
            return
            
        # å¤„ç†å½“å‰å­”ä½
        current_hole = self.detection_holes[self.detection_index]
        
        # æ¨¡æ‹Ÿæ£€æµ‹ç»“æœ
        import random
        status = random.choice(['qualified', 'defective', 'blind'])
        
        # æ›´æ–°çŠ¶æ€
        self.business_service.update_hole_status(current_hole.hole_id, status)
        self.status_updated.emit(current_hole.hole_id, status)
        
        # æ›´æ–°è¿›åº¦
        self.detection_progress.emit(self.detection_index + 1, len(self.detection_holes))
        
        # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå­”ä½
        self.detection_index += 1
        
    def start_snake_simulation(self):
        """å¼€å§‹è›‡å½¢è·¯å¾„æ¨¡æ‹Ÿ"""
        if not self.hole_collection or not self.snake_path_coordinator:
            self.error_occurred.emit("è¯·å…ˆåŠ è½½DXFæ–‡ä»¶")
            return
            
        # è®¡ç®—è›‡å½¢è·¯å¾„
        holes = list(self.hole_collection.holes.values())
        self.snake_sorted_holes = self.snake_path_coordinator.calculate_snake_path(holes)
        self.snake_simulation_index = 0
        
        # å¼€å§‹æ¨¡æ‹Ÿ
        self._simulate_snake_movement()
        
    def _simulate_snake_movement(self):
        """æ¨¡æ‹Ÿè›‡å½¢è·¯å¾„ç§»åŠ¨"""
        if self.snake_simulation_index < len(self.snake_sorted_holes):
            current_hole = self.snake_sorted_holes[self.snake_simulation_index]
            
            # æ›´æ–°å½“å‰å­”ä½çŠ¶æ€
            self.business_service.update_hole_status(current_hole.hole_id, "processing")
            self.status_updated.emit(current_hole.hole_id, "processing")
            
            # ç»§ç»­ä¸‹ä¸€ä¸ª
            self.snake_simulation_index += 1
            QTimer.singleShot(50, self._simulate_snake_movement)
            
    def get_statistics(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        if not self.hole_collection:
            return {
                'total_holes': 0,
                'qualified': 0,
                'defective': 0,
                'blind': 0,
                'pending': 0
            }
            
        stats = {
            'total_holes': len(self.hole_collection.holes),
            'qualified': 0,
            'defective': 0,
            'blind': 0,
            'pending': 0
        }
        
        for hole in self.hole_collection.holes.values():
            status = getattr(hole, 'status', 'pending')
            # å¦‚æœstatusæ˜¯æšä¸¾ç±»å‹ï¼Œè·å–å…¶å€¼
            if hasattr(status, 'value'):
                status = status.value
            # è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶å°å†™
            status = str(status).lower()
            if status in stats:
                stats[status] += 1
            else:
                stats['pending'] += 1
                
        return stats
    
    def start_simulation(self):
        """å¼€å§‹è›‡å½¢è·¯å¾„æ¨¡æ‹Ÿæ£€æµ‹"""
        try:
            if not self.hole_collection:
                self.logger.warning("æ²¡æœ‰åŠ è½½å­”ä½æ•°æ®ï¼Œæ— æ³•å¼€å§‹æ¨¡æ‹Ÿ")
                self.error_occurred.emit("è¯·å…ˆåŠ è½½DXFæ–‡ä»¶æˆ–é€‰æ‹©äº§å“")
                return
                
            if not self.snake_path_coordinator:
                self.logger.warning("è›‡å½¢è·¯å¾„åè°ƒå™¨æœªåˆå§‹åŒ–")
                return
                
            self.logger.info(f"ğŸ å¼€å§‹è›‡å½¢è·¯å¾„æ¨¡æ‹Ÿï¼Œå…± {len(self.hole_collection.holes)} ä¸ªå­”ä½")
            
            # è·å–è›‡å½¢è·¯å¾„æ’åºåçš„å­”ä½
            holes_list = list(self.hole_collection.holes.values())
            self.snake_sorted_holes = self.snake_path_coordinator.get_snake_path_order(holes_list)
            
            if not self.snake_sorted_holes:
                self.error_occurred.emit("æ— æ³•ç”Ÿæˆè›‡å½¢è·¯å¾„")
                return
                
            # é‡ç½®ç´¢å¼•
            self.snake_simulation_index = 0
            self.is_simulation_running = True
            self.is_simulation_paused = False
            
            # å¯åŠ¨å®šæ—¶å™¨ï¼Œæ¯100mså¤„ç†ä¸€ä¸ªå­”ä½
            self.simulation_timer.start(100)
            
            self.logger.info(f"âœ… æ¨¡æ‹Ÿå¼€å§‹ï¼Œè·¯å¾„åŒ…å« {len(self.snake_sorted_holes)} ä¸ªå­”ä½")
            
        except Exception as e:
            self.logger.error(f"å¯åŠ¨æ¨¡æ‹Ÿå¤±è´¥: {e}")
            self.error_occurred.emit(f"å¯åŠ¨æ¨¡æ‹Ÿå¤±è´¥: {e}")
    
    def pause_simulation(self):
        """æš‚åœæ¨¡æ‹Ÿ"""
        if self.is_simulation_running and not self.is_simulation_paused:
            self.is_simulation_paused = True
            self.simulation_timer.stop()
            self.logger.info("â¸ï¸ æ¨¡æ‹Ÿå·²æš‚åœ")
    
    def resume_simulation(self):
        """æ¢å¤æ¨¡æ‹Ÿ"""  
        if self.is_simulation_running and self.is_simulation_paused:
            self.is_simulation_paused = False
            self.simulation_timer.start(100)
            self.logger.info("â–¶ï¸ æ¨¡æ‹Ÿå·²æ¢å¤")
    
    def stop_simulation(self):
        """åœæ­¢æ¨¡æ‹Ÿ"""
        self.is_simulation_running = False
        self.is_simulation_paused = False
        self.simulation_timer.stop()
        self.snake_simulation_index = 0
        self.logger.info("â¹ï¸ æ¨¡æ‹Ÿå·²åœæ­¢")
        
        # é‡ç½®æ‰€æœ‰å­”ä½çŠ¶æ€
        if self.hole_collection:
            for hole in self.hole_collection.holes.values():
                hole.status = "pending"
    
    def _process_simulation_step(self):
        """å¤„ç†æ¨¡æ‹Ÿæ£€æµ‹çš„å•ä¸ªæ­¥éª¤"""
        try:
            if not self.is_simulation_running or self.is_simulation_paused:
                return
                
            if self.snake_simulation_index >= len(self.snake_sorted_holes):
                # æ¨¡æ‹Ÿå®Œæˆ
                self.stop_simulation()
                self.logger.info("âœ… æ¨¡æ‹Ÿæ£€æµ‹å®Œæˆ")
                return
                
            # è·å–å½“å‰å­”ä½
            current_hole = self.snake_sorted_holes[self.snake_simulation_index]
            
            # æ¨¡æ‹Ÿæ£€æµ‹ç»“æœï¼ˆ99.5%åˆæ ¼ç‡ï¼‰
            import random
            if random.random() < 0.995:
                status = "qualified"
            else:
                status = "defective"
                
            # æ›´æ–°å­”ä½çŠ¶æ€
            current_hole.status = status
            self.status_updated.emit(current_hole.hole_id, status)
            
            # æ›´æ–°è¿›åº¦
            progress = int((self.snake_simulation_index + 1) / len(self.snake_sorted_holes) * 100)
            self.detection_progress.emit(self.snake_simulation_index + 1, len(self.snake_sorted_holes))
            
            # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå­”ä½
            self.snake_simulation_index += 1
            
        except Exception as e:
            self.logger.error(f"æ¨¡æ‹Ÿæ­¥éª¤å¤„ç†å¤±è´¥: {e}")
            self.stop_simulation()
        
    def cleanup(self):
        """æ¸…ç†èµ„æº"""
        self.detection_timer.stop()
        self.business_service.cleanup()
        self.graphics_service.cleanup()
        self.logger.info("MainWindow controller cleaned up")